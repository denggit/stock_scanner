# 统一量化回测引擎开发文档 (v1.0)

## 1. 项目目标与设计哲学

### 1.1 项目目标

本项目旨在为 `stock_scanner` 平台开发一个全新的、轻量级且高性能的量化回测引擎。新引擎将替换现有的 Backtrader 内核，从根本上解决其在处理动态股票池（新股、退市股）时的“短板效应”问题，并提供一个更现代化、更简洁、更符合直觉的策略开发 API。

最终目标是构建一个**稳定、高效、可扩展**的底层框架，该框架一经建成便无需频繁改动，能够统一支持**事件驱动型策略**和**截面因子型策略**的研发与回测。

### 1.2 设计哲学

-   **时间驱动，而非数据驱动**: 系统的核心脉搏是交易日历的推进，确保回测的完整性，杜绝因个别股票数据长度不足而截断回测周期的问题。
-   **关注点分离 (SoC)**: 严格划分引擎、数据、组合、策略四大核心组件的职责，实现高度模块化和低耦合，便于独立开发、测试和维护。
-   **约定优于配置**: 提供一套清晰、标准的 API 接口。策略开发者只需继承基类并实现指定方法，无需关心底层复杂的实现细节。
-   **Pandas 原生亲和**: 框架内部数据流转将优先使用 Pandas DataFrame/Series，让策略编写与数据分析无缝衔接，提升开发效率。

---

## 2. 架构与目录结构

我们将在现有的 `stock_scanner` 项目中进行“心脏移植手术”。新的回测引擎将存在于一个新的目录结构下，旧代码可暂时备份。

### 2.1 建议目录结构

在 `backend/business/` 目录下进行如下操作：

1.  将原 `backtest` 文件夹重命名为 `backtest_legacy` 作为备份。
2.  创建新的 `backtest` 文件夹，其内部结构如下：

```
/backend/business/
|-- backtest/
|   |-- core/
|   |   |-- __init__.py
|   |   |-- engine.py             # 【核心】回测主引擎
|   |   |-- data_provider.py      # 【核心】统一数据提供者
|   |   |-- portfolio.py          # 【核心】投资组合与订单管理器
|   |   |-- context.py            # 【核心】上下文对象定义
|   |   `-- event.py              # (可选) 事件类型定义
|   |
|   |-- strategies/
|   |   |-- __init__.py
|   |   |-- base.py               # 【核心】所有策略的抽象基类
|   |   `-- implementations/      # 存放具体策略实现
|   |       |-- __init__.py
|   |       |-- rising_channel.py
|   |       `-- small_cap.py
|   |
|   |-- analysis/
|   |   |-- __init__.py
|   |   `-- report.py             # 回测报告生成与分析
|   |
|   |-- __init__.py
|   `-- run_backtest.py           # 回测任务的入口脚本
|
`-- backtest_legacy/              # 旧代码备份
```

---

## 3. 核心组件详解 (Core Components)

这是新引擎的四大支柱，需要优先实现。

### 3.1 `DataProvider` (统一数据提供者)

-   **文件路径**: `backend/business/backtest/core/data_provider.py`
-   **职责**: 作为回测引擎唯一的数据来源。它将封装您项目中的 `data_manager` 和 `factor` 模块，为上层提供统一、标准化的数据接口。
-   **核心实现**:
    1.  **数据预加载**: 在初始化时，根据回测的起止日期，一次性从数据库加载所有可能用到的日线行情、财务数据、因子数据到内存中。
    2.  **高效数据结构**: 使用 `pandas.MultiIndex` DataFrame (也称为 Panel data) 存储数据是最高效的方式。`MultiIndex` 应为 `(date, stock_code)`。
    3.  **API 设计**:

```python
# data_provider.py
import pandas as pd

class DataProvider:
    def __init__(self, stock_codes: list, start_date: str, end_date: str):
        # 1. 预加载所有数据
        self.market_data = self._load_market_data(stock_codes, start_date, end_date)
        self.factor_data = self._load_factor_data(stock_codes, start_date, end_date)
        self.trading_days = self.market_data.index.get_level_values('date').unique().sort_values()

    def _load_market_data(self, ...) -> pd.DataFrame:
        # 实现从数据库加载日线行情 (open, high, low, close, volume, ...)
        # 返回一个以 (date, stock_code) 为 MultiIndex 的 DataFrame
        pass

    def _load_factor_data(self, ...) -> dict[str, pd.DataFrame]:
        # 实现加载所有因子数据
        # 返回一个字典, key为因子名, value为 (date, stock_code) MultiIndex 的 DataFrame
        pass

    def get_daily_bars(self, date: pd.Timestamp) -> pd.DataFrame:
        """获取指定日期的所有股票的行情截面数据。"""
        try:
            return self.market_data.loc[date]
        except KeyError:
            return pd.DataFrame()

    def get_history_data(self, stock_code: str, end_date: pd.Timestamp, lookback_days: int) -> pd.DataFrame:
        """获取单个股票到指定日期为止的历史行情数据。"""
        # 实现从 self.market_data 中高效切片
        pass

    def get_factor_values(self, factor_name: str, date: pd.Timestamp) -> pd.Series:
        """获取指定日期的指定因子在所有股票上的截面值。"""
        try:
            return self.factor_data[factor_name].loc[date]
        except KeyError:
            return pd.Series()
```

### 3.2 `PortfolioManager` & `Context` (投资组合与上下文)

-   **文件路径**: `backend/business/backtest/core/portfolio.py` 和 `context.py`
-   **职责**:
    -   `PortfolioManager`: 管理账户的一切状态（现金、持仓、市值），处理交易指令，模拟撮合，计算费用。
    -   `Context`: 作为策略与引擎其他部分交互的“遥控器”，它持有对 `PortfolioManager` 和 `DataProvider` 的引用。
-   **API 设计**:

```python
# context.py
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .data_provider import DataProvider
    from .portfolio import PortfolioManager

class Context:
    def __init__(self, data_provider: 'DataProvider', portfolio_manager: 'PortfolioManager'):
        self.data_provider = data_provider
        self.portfolio = portfolio_manager
        self.current_dt: pd.Timestamp = None
        # 允许策略动态添加自定义属性
        # e.g., self.custom_variable = "hello"

# portfolio.py
from .context import Context

class Position:
    # 定义持仓对象 (股票代码, 数量, 成本, 最新价, 市值等)
    pass

class Order:
    # 定义订单对象 (订单ID, 股票代码, 数量, 状态, 创建时间等)
    pass

class PortfolioManager:
    def __init__(self, initial_cash: float, data_provider: DataProvider):
        # ... 初始化 cash, positions, total_value ...
        self.context = Context(data_provider, self)
        self.open_orders = []
        self.trade_records = []
        self.daily_net_values = []

    # --- 暴露给策略的交易 API ---
    def order(self, stock_code: str, amount: int, order_type: str = 'market'):
        """按股数下单。正为买，负为卖。"""
        # 1. 创建 Order 对象
        # 2. 检查现金是否足够 (如果是买单)
        # 3. 将订单添加到 self.open_orders
        pass

    def order_value(self, stock_code: str, value: float):
        """按价值下单。"""
        pass
    
    def order_target(self, stock_code: str, amount: int):
        """调整目标仓位到指定股数。"""
        pass

    def order_target_value(self, stock_code: str, value: float):
        """调整目标仓位到指定价值。"""
        pass

    # --- 引擎内部调用的方法 ---
    def process_orders(self, daily_bars: pd.DataFrame):
        """在每日循环中，根据当天行情处理所有待处理订单。"""
        # 遍历 self.open_orders
        # 假设按收盘价成交: trade_price = daily_bars.loc[order.stock_code]['close']
        # 计算手续费和滑点
        # 更新 self.positions 和 self.cash
        # 创建成交记录 self.trade_records
        # 清空 self.open_orders
        pass

    def update_portfolio_value(self, date: pd.Timestamp, daily_bars: pd.DataFrame):
        """在每日收盘后，更新组合总净值。"""
        # 计算持仓市值
        # total_value = self.cash + market_value
        # self.daily_net_values.append({'date': date, 'net_value': total_value})
        pass
```

### 3.3 `BacktestEngine` (回测主引擎)

-   **文件路径**: `backend/business/backtest/core/engine.py`
-   **职责**: 驱动整个回测流程，是所有组件的“调度中心”。
-   **核心实现**:

```python
# engine.py
from .data_provider import DataProvider
from .portfolio import PortfolioManager
from ..strategies.base import BaseStrategy

class BacktestEngine:
    def __init__(self, start_date: str, end_date: str, initial_cash: float):
        self.start_date = start_date
        self.end_date = end_date
        self.initial_cash = initial_cash

    def run(self, strategy_class: type[BaseStrategy], strategy_params: dict, stock_codes: list):
        # 1. 初始化所有组件
        data_provider = DataProvider(stock_codes, self.start_date, self.end_date)
        portfolio_manager = PortfolioManager(self.initial_cash, data_provider)
        strategy = strategy_class(portfolio_manager.context, strategy_params)

        # 2. 调用策略初始化
        strategy.initialize()

        # 3. 主事件循环
        for current_date in data_provider.trading_days:
            portfolio_manager.context.current_dt = current_date

            # a. 开盘前事件
            strategy.before_trading_start()

            # b. 获取当天数据并调用策略核心逻辑
            daily_bars = data_provider.get_daily_bars(current_date)
            if not daily_bars.empty:
                strategy.handle_data(daily_bars)

            # c. 订单撮合与结算
            portfolio_manager.process_orders(daily_bars)
            
            # d. 收盘后事件
            strategy.after_trading_end()

            # e. 更新当日组合净值
            portfolio_manager.update_portfolio_value(current_date, daily_bars)

        # 4. 回测结束, 调用分析模块
        # report = self.generate_report(portfolio_manager.daily_net_values, ...)
        # return report
        print("Backtest Finished!")
        return portfolio_manager.daily_net_values # 简化返回
```

### 3.4 `BaseStrategy` (策略抽象基类)

-   **文件路径**: `backend/business/backtest/strategies/base.py`
-   **职责**: 定义所有策略都必须遵守的“合同”。策略开发者通过继承它并实现其方法来编写自己的逻辑。
-   **API 设计**:

```python
# base.py
from abc import ABC, abstractmethod
import pandas as pd
from ..core.context import Context

class BaseStrategy(ABC):
    def __init__(self, context: Context, params: dict = None):
        self.context = context
        self.params = params or {}

    def initialize(self):
        """
        【可选实现】初始化函数。
        回测开始前调用，且只调用一次。
        适合用于设置策略的初始参数、全局变量等。
        """
        pass

    def before_trading_start(self):
        """
        【可选实现】每日开盘前调用。
        适合用于每日股票池的筛选、计算当日需要使用的技术指标等。
        """
        pass

    @abstractmethod
    def handle_data(self, daily_bars: pd.DataFrame):
        """
        【必须实现】核心策略逻辑函数。
        每个交易日调用一次（如果当天有数据）。
        参数 `daily_bars` 是一个 DataFrame，包含了当天所有股票的行情数据。
        """
        raise NotImplementedError

    def after_trading_end(self):
        """
        【可选实现】每日收盘后调用。
        适合用于当日的复盘、记录日志、状态重置等。
        """
        pass
```

---

## 4. 开发路线图 (Roadmap)

建议按照以下步骤，循序渐进地完成开发：

1.  **Phase 1: 搭建骨架**
    -   [ ] 按照 2.1 节的规划，创建新的目录结构和所有空白的 Python 文件。
    -   [ ] 编写 `BaseStrategy` 类的完整定义。

2.  **Phase 2: 实现数据与状态管理**
    -   [ ] 实现 `DataProvider` 类。初期可以只实现 `_load_market_data` 和 `get_daily_bars`，数据加载逻辑可以复用您现有的 `channel_db_manager`。
    -   [ ] 实现 `Context`, `Position`, `Order` 类。
    -   [ ] 实现 `PortfolioManager` 类，重点完成 `__init__`, `order` (仅创建订单对象), `update_portfolio_value`。此时 `process_orders` 可以暂时为空。

3.  **Phase 3: 驱动核心引擎**
    -   [ ] 实现 `BacktestEngine` 的 `run` 方法。完成整个主循环的调度逻辑。
    -   [ ] 实现 `PortfolioManager` 中的 `process_orders` 核心逻辑，完成模拟成交。**这是关键一步**，初期可以只支持市价单，按收盘价成交。

4.  **Phase 4: 策略迁移与测试**
    -   [ ] 编写一个最简单的测试策略（例如：持有不动策略，或随机买卖策略）来验证整个框架是否能跑通。
    -   [ ] 将您现有的 `rising_channel` 策略迁移到继承自 `BaseStrategy` 的新类中。适配新的 `context` 和 `handle_data` 接口。
    -   [ ] 编写 `run_backtest.py` 脚本，作为回测任务的入口，调用 `BacktestEngine` 并传入 `RisingChannelStrategy`。

5.  **Phase 5: 完善与扩展**
    -   [ ] 在 `PortfolioManager` 中增加手续费和滑点的计算逻辑。
    -   [ ] 完善 `DataProvider`，增加对因子数据的加载和查询 (`_load_factor_data`, `get_factor_values`)。
    -   [ ] 在 `analysis/report.py` 中，使用 `quantstats` 等库，根据 `daily_net_values` 和 `trade_records` 生成专业的回测报告。