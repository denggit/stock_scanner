# 🚀 上升通道回归模块使用示例

## 📋 目录

- [🎯 基本使用](#-基本使用)
- [📊 历史数据分析](#-历史数据分析)
- [⚙️ 参数配置](#️-参数配置)
- [🔍 高级功能](#-高级功能)
- [📈 性能优化](#-性能优化)
- [🐛 故障排除](#-故障排除)

---

## 🎯 基本使用

### 1.1 单点通道拟合

```python
import pandas as pd
import numpy as np
from backend.business.factor.core.engine.library.channel_analysis.rising_channel import AscendingChannelRegression

# 准备数据
df = pd.DataFrame({
    'trade_date': pd.date_range('2023-01-01', periods=200, freq='D'),
    'open': [10 + i * 0.01 + np.random.normal(0, 0.1) for i in range(200)],
    'high': [10 + i * 0.01 + np.random.normal(0, 0.2) for i in range(200)],
    'low': [10 + i * 0.01 - np.random.normal(0, 0.2) for i in range(200)],
    'close': [10 + i * 0.01 + np.random.normal(0, 0.1) for i in range(200)],
    'volume': [np.random.randint(1000000, 10000000) for _ in range(200)]
})

# 初始化分析器
analyzer = AscendingChannelRegression()

# 拟合通道
state = analyzer.fit_channel(df)

# 获取结果
result = state.to_dict()
print(result)
```

**返回结果字段说明：**

```python
{
    # 回归参数
    "beta": 0.0216,           # 斜率 β_t
    "sigma": 0.4717,          # 标准差 σ_t
    "r2": 0.6832,             # 回归拟合优度 R²
    
    # 通道边界（当前）
    "mid_today": 14.7545,     # 今日中轴价
    "upper_today": 15.6980,   # 今日上沿价
    "lower_today": 13.8111,   # 今日下沿价
    
    # 通道边界（明日预测）
    "mid_tomorrow": 14.7762,  # 明日预测中轴价
    "upper_tomorrow": 15.7197, # 明日预测上沿价
    "lower_tomorrow": 13.8327, # 明日预测下沿价
    
    # 通道状态
    "channel_status": "NORMAL", # 通道状态 (NORMAL/BREAKOUT/BREAKDOWN)
    
    # 锚点信息
    "anchor_date": "2023-03-31T00:00:00",  # 锚点日期
    "anchor_price": 11.5916,               # 锚点价格
    
    # 突破计数器
    "break_cnt_up": 0,        # 连续突破上沿次数
    "break_cnt_down": 0,      # 连续突破下沿次数
    
    # 重锚失败计数器
    "reanchor_fail_up": 0,    # 重锚失败（上沿）
    "reanchor_fail_down": 0,  # 重锚失败（下沿）
    
    # 其他信息
    "cumulative_gain": 0.3445, # 累计涨幅
    "last_update": "2023-07-19T00:00:00", # 最后更新时间
    "window_size": 108,       # 窗口大小
    "days_since_anchor": 107, # 距离锚点天数
    
    # 分析字段
    "width_pct": 0.1229,      # 通道宽度百分比 (上沿-下沿)/中轴价
    "slope_deg": 1.4052,      # 斜率角度（度）
    "volatility": 0.0320      # 波动率 σ/中轴价
}
```

### 1.2 使用技术指标工具

```python
from backend.utils.indicators import CalIndicators

# 使用技术指标工具计算上升通道
channel_info = CalIndicators.ascending_channel(df, **params)

print(f"斜率: {channel_info['beta']:.4f}")
print(f"通道状态: {channel_info['channel_status']}")
print(f"拟合质量: {channel_info['r2']:.3f}")
```

---

## 📊 历史数据分析

### 2.1 历史通道拟合

```python
# 计算历史通道数据
history_df = analyzer.fit_channel_history(df, min_window_size=60)

print(f"历史数据形状: {history_df.shape}")
print(f"历史数据列: {list(history_df.columns)}")
```

**历史数据新增字段：**

```python
# 新增字段说明
{
    "r2": 0.6832,             # 回归拟合优度 R²
    "break_reason": "invalid_width",  # 通道失效原因 (insufficient_data/no_valid_anchor/invalid_regression/invalid_width)
    "width_pct": 0.1229,      # 通道宽度百分比 (上沿-下沿)/中轴价
    "slope_deg": 1.4052,      # 斜率角度（度）
    "volatility": 0.0320      # 波动率 σ/中轴价
}
```

### 2.2 优化计算（按步长）

```python
# 优化计算（按步长）
history_df = analyzer.fit_channel_history_optimized(
    df, 
    min_window_size=60, 
    step_days=5
)

print(f"优化后数据形状: {history_df.shape}")
```

### 2.3 增量更新

```python
# 增量更新
new_data = pd.DataFrame({
    'trade_date': pd.date_range('2023-08-01', periods=10, freq='D'),
    'close': [15 + i * 0.01 + np.random.normal(0, 0.1) for i in range(10)]
})

updated_df = analyzer.update_channel_history_incremental(
    history_df, 
    new_data
)

print(f"更新后数据形状: {updated_df.shape}")
```

---

## ⚙️ 参数配置

### 3.1 基础参数

```python
# 基础参数配置
params = {
    "k": 2.0,                 # 通道宽度倍数，影响通道的宽度 (±k·σ)
    "L_max": 120,             # 窗口最长天数，超出后向右滑动
    "delta_cut": 5,           # 滑动时一次剔除最早的天数
    "pivot_m": 3              # 判断pivot low的宽度参数 (m左m右更高)
}

# 使用自定义参数
state = analyzer.fit_channel(df, **params)
```

### 3.2 触发参数

```python
# 触发参数配置
params = {
    "gain_trigger": 0.30,     # 累计涨幅触发重锚的阈值
    "beta_delta": 0.15,       # 斜率变化阈值 (±15%)
    "break_days": 3,          # 连续n日突破上下沿视为失效
    "reanchor_fail_max": 2    # 连续n次重锚仍突破/跌破时进入极端状态
}
```

### 3.3 质量参数

```python
# 质量参数配置
params = {
    "min_data_points": 60,    # 最小有效数据点要求
    "R2_min": 0.20,           # 最小回归拟合优度，低于此视为无效通道
    "width_pct_min": 0.04,    # 通道宽度下限，小于此视为过窄
    "width_pct_max": 0.12     # 通道宽度上限，超过此视为过宽
}
```

---

## 🔍 高级功能

### 4.1 通道状态监控

```python
# 监控通道状态变化
def monitor_channel_status(df):
    analyzer = AscendingChannelRegression()
    state = analyzer.fit_channel(df)
    
    status = state.channel_status
    if status == "NORMAL":
        print("✅ 通道状态正常")
    elif status == "BREAKOUT":
        print("🚀 上沿突破")
    elif status == "BREAKDOWN":
        print("📉 跌破/失效")
    
    return state

# 使用示例
state = monitor_channel_status(df)
```

### 4.2 通道质量评估

```python
def evaluate_channel_quality(channel_info):
    """评估通道质量"""
    
    # 拟合质量评估
    r2 = channel_info.get('r2', 0)
    if r2 > 0.7:
        quality = "优秀"
    elif r2 > 0.5:
        quality = "良好"
    else:
        quality = "一般"
    
    # 通道宽度评估
    width_pct = channel_info.get('width_pct', 0)
    if width_pct < 0.05:
        width_quality = "过窄"
    elif width_pct > 0.15:
        width_quality = "过宽"
    else:
        width_quality = "适中"
    
    # 趋势强度评估
    slope_deg = channel_info.get('slope_deg', 0)
    if slope_deg > 5:
        trend_strength = "强"
    elif slope_deg > 1:
        trend_strength = "中"
    else:
        trend_strength = "弱"
    
    return {
        "拟合质量": f"{quality} ({r2:.3f})",
        "通道宽度": f"{width_quality} ({width_pct:.2%})",
        "趋势强度": f"{trend_strength} ({slope_deg:.2f}°)"
    }

# 使用示例
quality_report = evaluate_channel_quality(channel_info)
for metric, value in quality_report.items():
    print(f"{metric}: {value}")
```

### 4.3 预测功能

```python
def predict_channel_levels(channel_info, days_ahead=5):
    """预测未来几天的通道水平"""
    
    beta = channel_info.get('beta', 0)
    mid_today = channel_info.get('mid_today', 0)
    upper_today = channel_info.get('upper_today', 0)
    lower_today = channel_info.get('lower_today', 0)
    
    predictions = []
    for day in range(1, days_ahead + 1):
        mid_pred = mid_today + beta * day
        upper_pred = upper_today + beta * day
        lower_pred = lower_today + beta * day
        
        predictions.append({
            "day": day,
            "mid": mid_pred,
            "upper": upper_pred,
            "lower": lower_pred
        })
    
    return predictions

# 使用示例
predictions = predict_channel_levels(channel_info, days_ahead=5)
for pred in predictions:
    print(f"第{pred['day']}天: 中轴={pred['mid']:.2f}, 上沿={pred['upper']:.2f}, 下沿={pred['lower']:.2f}")
```

---

## 📈 性能优化

### 5.1 批量处理

```python
def batch_process_stocks(stock_codes, start_date, end_date):
    """批量处理多只股票的上升通道分析"""
    
    analyzer = AscendingChannelRegression()
    results = {}
    
    for code in stock_codes:
        try:
            # 获取股票数据
            df = get_stock_data(code, start_date, end_date)
            
            # 计算上升通道
            state = analyzer.fit_channel(df)
            results[code] = state.to_dict()
            
        except Exception as e:
            print(f"处理股票 {code} 时出错: {e}")
            results[code] = None
    
    return results

# 使用示例
stock_codes = ["000001", "000002", "600000"]
results = batch_process_stocks(stock_codes, "2024-01-01", "2024-12-31")
```

### 5.2 缓存优化

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def cached_channel_analysis(stock_code, start_date, end_date):
    """缓存上升通道分析结果"""
    
    analyzer = AscendingChannelRegression()
    df = get_stock_data(stock_code, start_date, end_date)
    state = analyzer.fit_channel(df)
    
    return state.to_dict()

# 使用示例
result1 = cached_channel_analysis("000001", "2024-01-01", "2024-12-31")
result2 = cached_channel_analysis("000001", "2024-01-01", "2024-12-31")  # 使用缓存
```

### 5.3 并行处理

```python
import concurrent.futures
from multiprocessing import Pool

def parallel_channel_analysis(stock_codes, start_date, end_date):
    """并行处理上升通道分析"""
    
    def process_single_stock(code):
        try:
            analyzer = AscendingChannelRegression()
            df = get_stock_data(code, start_date, end_date)
            state = analyzer.fit_channel(df)
            return code, state.to_dict()
        except Exception as e:
            return code, None
    
    # 使用线程池
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(process_single_stock, code) for code in stock_codes]
        results = {}
        
        for future in concurrent.futures.as_completed(futures):
            code, result = future.result()
            results[code] = result
    
    return results

# 使用示例
stock_codes = ["000001", "000002", "600000", "600036"]
results = parallel_channel_analysis(stock_codes, "2024-01-01", "2024-12-31")
```

---

## 🐛 故障排除

### 6.1 常见错误

```python
# 1. 数据不足错误
try:
    state = analyzer.fit_channel(df)
except ValueError as e:
    if "insufficient_data" in str(e):
        print("数据量不足，需要至少60个交易日的数据")
    elif "no_valid_anchor" in str(e):
        print("未找到有效的锚点")
    elif "invalid_regression" in str(e):
        print("回归分析失败，拟合质量过低")

# 2. 参数错误
try:
    state = analyzer.fit_channel(df, k=-1)  # 无效参数
except ValueError as e:
    print(f"参数错误: {e}")

# 3. 数据格式错误
try:
    state = analyzer.fit_channel(df)
except KeyError as e:
    print(f"数据格式错误，缺少必需列: {e}")
```

### 6.2 数据验证

```python
def validate_data_for_channel_analysis(df):
    """验证数据是否适合上升通道分析"""
    
    # 检查必需列
    required_columns = ['trade_date', 'close']
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        return False, f"缺少必需列: {missing_columns}"
    
    # 检查数据量
    if len(df) < 60:
        return False, f"数据量不足，当前{len(df)}条，需要至少60条"
    
    # 检查数据类型
    if not pd.api.types.is_datetime64_any_dtype(df['trade_date']):
        return False, "trade_date列必须是日期类型"
    
    # 检查数值列
    if not pd.api.types.is_numeric_dtype(df['close']):
        return False, "close列必须是数值类型"
    
    # 检查是否有空值
    if df['close'].isna().any():
        return False, "close列包含空值"
    
    return True, "数据验证通过"

# 使用示例
is_valid, message = validate_data_for_channel_analysis(df)
if not is_valid:
    print(f"数据验证失败: {message}")
else:
    print("数据验证通过，可以进行分析")
```

### 6.3 调试模式

```python
import logging

# 设置调试日志
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def debug_channel_analysis(df):
    """调试模式下的上升通道分析"""
    
    logger.debug(f"输入数据形状: {df.shape}")
    logger.debug(f"数据列: {list(df.columns)}")
    logger.debug(f"数据范围: {df['trade_date'].min()} 到 {df['trade_date'].max()}")
    
    analyzer = AscendingChannelRegression()
    
    try:
        state = analyzer.fit_channel(df)
        logger.debug(f"分析成功，通道状态: {state.channel_status}")
        return state
    except Exception as e:
        logger.error(f"分析失败: {e}")
        raise

# 使用示例
state = debug_channel_analysis(df)
```

---

## 📚 完整示例

### 7.1 完整的上升通道分析流程

```python
import pandas as pd
import numpy as np
from backend.business.factor.core.engine.library.channel_analysis import AscendingChannelRegression
from backend.business.data.data_fetcher import StockDataFetcher

def complete_channel_analysis(stock_code, start_date, end_date):
    """完整的上升通道分析流程"""
    
    # 1. 获取数据
    fetcher = StockDataFetcher()
    df = fetcher.fetch_stock_data(stock_code, start_date, end_date)
    
    # 2. 数据验证
    is_valid, message = validate_data_for_channel_analysis(df)
    if not is_valid:
        print(f"数据验证失败: {message}")
        return None
    
    # 3. 上升通道分析
    analyzer = AscendingChannelRegression()
    state = analyzer.fit_channel(df)
    channel_info = state.to_dict()
    
    # 4. 质量评估
    quality_report = evaluate_channel_quality(channel_info)
    
    # 5. 预测
    predictions = predict_channel_levels(channel_info, days_ahead=5)
    
    # 6. 结果汇总
    result = {
        "stock_code": stock_code,
        "analysis_date": end_date,
        "channel_info": channel_info,
        "quality_report": quality_report,
        "predictions": predictions
    }
    
    return result

# 使用示例
result = complete_channel_analysis("000001", "2024-01-01", "2024-12-31")

if result:
    print(f"股票代码: {result['stock_code']}")
    print(f"分析日期: {result['analysis_date']}")
    print(f"通道状态: {result['channel_info']['channel_status']}")
    print(f"拟合质量: {result['quality_report']['拟合质量']}")
    print(f"通道宽度: {result['quality_report']['通道宽度']}")
    print(f"趋势强度: {result['quality_report']['趋势强度']}")
```

---

**最后更新时间**: 2025年8月5日
**文档版本**: v2.0 