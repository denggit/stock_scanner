# 上升通道回归模块使用示例

## 📋 模块概述

上升通道回归模块是一个用于自动检测、维护并输出最新**上升回归通道**信息的量化分析工具。该模块基于线性回归算法，能够自动识别股票价格的上升趋势通道，并提供实时的通道边界预测。

## 🚀 快速开始

### 1. 基本使用

```python
import pandas as pd
from backend.quant.core.factor_engine.factor_library.channel_analysis import AscendingChannelRegression

# 初始化分析器
channel_analyzer = AscendingChannelRegression()

# 准备数据（至少需要60个交易日的数据）
df = pd.DataFrame({
    'trade_date': [...],  # 日期序列
    'open': [...],        # 开盘价
    'high': [...],        # 最高价
    'low': [...],         # 最低价
    'close': [...],       # 收盘价
    'volume': [...]       # 成交量
})

# 拟合上升通道
state = channel_analyzer.fit_channel(df)

# 获取通道信息
channel_info = state.to_dict()
print(f"斜率: {channel_info['beta']:.4f}")
print(f"今日中轴: {channel_info['mid_today']:.2f}")
print(f"今日上沿: {channel_info['upper_today']:.2f}")
print(f"今日下沿: {channel_info['lower_today']:.2f}")
print(f"通道状态: {channel_info['channel_status']}")
```

### 2. 实时更新

```python
# 每日更新通道状态
new_bar = {
    'trade_date': '2024-12-19',
    'open': 45.20,
    'high': 46.50,
    'low': 44.80,
    'close': 45.90,
    'volume': 5000000
}

# 更新通道
result = channel_analyzer.update(state, new_bar)

# 检查更新结果
print(f"更新后斜率: {result['beta']:.4f}")
print(f"明日预测中轴: {result['mid_tomorrow']:.2f}")
print(f"明日预测上沿: {result['upper_tomorrow']:.2f}")
print(f"明日预测下沿: {result['lower_tomorrow']:.2f}")
```

## 📊 输出格式

### 通道信息字典

```python
{
    "beta": 0.0427,              # 最新斜率 beta_t
    "mid_today": 34.89,          # 今日中轴价
    "upper_today": 36.51,        # 今日上沿价
    "lower_today": 33.28,        # 今日下沿价
    "mid_tomorrow": 34.93,       # 预估下一交易日中轴价
    "upper_tomorrow": 36.55,     # 预估下一交易日上沿价
    "lower_tomorrow": 33.31,     # 预估下一交易日下沿价
    "channel_status": "NORMAL",  # 通道状态
    "anchor_date": "2024-01-15T00:00:00",  # 锚点日期
    "anchor_price": 30.50,       # 锚点价格
    "break_cnt_up": 0,           # 连续突破上沿次数
    "break_cnt_down": 0,         # 连续突破下沿次数
    "reanchor_fail_up": 0,       # 重锚失败次数（上沿）
    "reanchor_fail_down": 0,     # 重锚失败次数（下沿）
    "cumulative_gain": 0.1575,   # 累计涨幅
    "last_update": "2024-12-19T00:00:00"  # 最后更新时间
}
```

### 通道状态说明

| 状态 | 描述 | 含义 |
|------|------|------|
| `NORMAL` | 通道正常 | 价格在通道内正常波动 |
| `ACCEL_BREAKOUT` | 加速突破 | 连续突破上沿，可能进入加速上涨 |
| `BREAKDOWN` | 跌破下沿 | 连续跌破下沿，趋势可能反转 |
| `BROKEN` | 通道失效 | 通道已失效，需要重新建立 |

## ⚙️ 配置参数

### 默认配置

```yaml
ascending_channel:
  k: 2.0                    # 通道宽度倍数 (±k·σ)
  L_max: 120                # 窗口最长天数
  delta_cut: 5              # 滑动时一次剔除天数
  pivot_m: 3                # 判断pivot的宽度参数
  gain_trigger: 0.30        # 累计涨幅触发重锚
  beta_delta: 0.15          # 斜率变化阈值
  break_days: 3             # 连续突破天数
  reanchor_fail_max: 2      # 重锚失败最大次数
  min_data_points: 60       # 最小数据要求
```

### 自定义配置

```python
# 使用自定义配置文件
channel_analyzer = AscendingChannelRegression(
    config_path="path/to/custom_config.yaml"
)

# 或者修改默认参数
channel_analyzer.k = 2.5  # 调整通道宽度
channel_analyzer.gain_trigger = 0.25  # 调整重锚触发条件
```

## 🔧 高级功能

### 1. 强制重锚

```python
# 在特殊情况下强制重锚
channel_analyzer.force_reanchor(state)
```

### 2. 锚点检测

```python
from backend.quant.core.factor_engine.factor_library.channel_analysis import PivotDetector

# 初始化锚点检测器
detector = PivotDetector(pivot_m=3)

# 检测pivot low
pivot_low = detector.find_pivot_low(df)
if pivot_low:
    date, price = pivot_low
    print(f"找到pivot low: {date} @ {price:.2f}")

# 检测pivot high
pivot_high = detector.find_pivot_high(df)
if pivot_high:
    date, price = pivot_high
    print(f"找到pivot high: {date} @ {price:.2f}")
```

### 3. 锚点验证

```python
# 验证锚点的有效性
is_valid = detector.validate_anchor(df, anchor_date, anchor_price, min_gain=0.05)
if is_valid:
    print("锚点验证通过")
else:
    print("锚点验证失败")
```

## 📈 实际应用场景

### 1. 策略扫描

```python
# 在策略扫描中使用
def scan_ascending_channels(stock_list):
    results = []
    
    for stock_code in stock_list:
        # 获取股票数据
        df = get_stock_data(stock_code, days=252)
        
        try:
            # 分析上升通道
            state = channel_analyzer.fit_channel(df)
            channel_info = state.to_dict()
            
            # 筛选符合条件的股票
            if (channel_info['channel_status'] == 'NORMAL' and 
                channel_info['beta'] > 0.02 and  # 斜率大于2%
                channel_info['cumulative_gain'] > 0.1):  # 累计涨幅大于10%
                
                results.append({
                    'code': stock_code,
                    'beta': channel_info['beta'],
                    'gain': channel_info['cumulative_gain'],
                    'status': channel_info['channel_status']
                })
                
        except Exception as e:
            print(f"分析股票 {stock_code} 失败: {e}")
    
    return results
```

### 2. 回测系统

```python
# 在回测系统中使用
def backtest_ascending_channel_strategy(df):
    # 初始化通道分析器
    analyzer = AscendingChannelRegression()
    
    # 拟合初始通道
    state = analyzer.fit_channel(df.iloc[:100])  # 使用前100天数据
    
    signals = []
    
    # 逐日更新
    for i in range(100, len(df)):
        bar = df.iloc[i].to_dict()
        result = analyzer.update(state, bar)
        
        # 生成交易信号
        if result['channel_status'] == 'ACCEL_BREAKOUT':
            signals.append(('BUY', bar['trade_date'], bar['close']))
        elif result['channel_status'] == 'BREAKDOWN':
            signals.append(('SELL', bar['trade_date'], bar['close']))
    
    return signals
```

### 3. 实时监控

```python
# 实时监控股票通道状态
def monitor_channel_status(stock_code):
    analyzer = AscendingChannelRegression()
    
    # 获取历史数据
    df = get_stock_data(stock_code, days=252)
    state = analyzer.fit_channel(df)
    
    # 实时更新
    while True:
        # 获取最新数据
        latest_bar = get_latest_bar(stock_code)
        
        # 更新通道
        result = analyzer.update(state, latest_bar)
        
        # 检查状态变化
        if result['channel_status'] != 'NORMAL':
            send_alert(f"股票 {stock_code} 通道状态变化: {result['channel_status']}")
        
        time.sleep(60)  # 每分钟检查一次
```

## ⚠️ 注意事项

1. **数据要求**: 至少需要60个交易日的数据
2. **数据质量**: 确保数据按时间排序，无缺失值
3. **参数调优**: 根据具体股票特性调整配置参数
4. **状态监控**: 及时关注通道状态变化
5. **异常处理**: 妥善处理数据不足等异常情况

## 🐛 常见问题

### Q: 为什么找不到有效的锚点？
A: 检查数据是否足够（至少60个交易日），以及是否包含明显的上升趋势。

### Q: 通道状态一直显示BROKEN？
A: 可能是股票处于下跌趋势，或者参数设置过于严格，可以调整 `break_days` 和 `reanchor_fail_max` 参数。

### Q: 如何提高检测精度？
A: 可以调整 `pivot_m` 参数来改变锚点检测的敏感度，或者调整 `k` 参数来改变通道宽度。

---

**最后更新**: 2024年12月19日
**版本**: v1.0 

# 【v0.2补充】本模块严格只做“上升通道”
- 所有锚点只用pivot_low，不再做任何趋势分流。
- fit_channel/fit_channel_history等方法只会输出“上升通道”或BROKEN。
- 不再根据30天斜率/涨幅判断趋势，也不会用pivot_high。

## 【v0.2补充】核心参数表

| 参数名           | 默认值 | 说明                                                         |
|------------------|--------|--------------------------------------------------------------|
| k                | 2.0    | 通道宽度倍数 (±k·σ)                                          |
| L_max            | 120    | 最大窗口长度（只在最后L_max天内找pivot_low）                 |
| delta_cut        | 5      | 滑动窗口剔除天数                                             |
| pivot_m          | 3      | pivot_low检测灵敏度                                          |
| gain_trigger     | 0.30   | 累计涨幅触发重锚                                             |
| beta_delta       | 0.15   | 斜率变化阈值                                                 |
| break_days       | 3      | 连续突破上下沿天数                                           |
| reanchor_fail_max| 2      | 连续重锚失败最大次数                                         |
| min_data_points  | 60     | 最小有效数据点                                               |
| R2_min           | 0.20   | 最小回归拟合优度，低于此视为无效通道                         |
| width_pct_min    | 0.04   | 通道宽度下限，过窄视为无效                                   |
| width_pct_max    | 0.12   | 通道宽度上限，过宽视为无效                                   |

## 【v0.2补充】fit_channel判定逻辑

1. 只在最后L_max天内找所有pivot_low。
2. 选最靠前且距今日≥min_data_points的最低pivot_low为锚点。
3. 从锚点到最新做线性回归，得到beta、sigma、r2。
4. 若beta≤0或r2<R2_min，直接BROKEN。
5. 计算通道上下沿，若(upper_today-lower_today)/mid_today不在[width_pct_min, width_pct_max]，也直接BROKEN。
6. 只有全部通过才输出NORMAL。

## 【v0.2补充】FAQ

- Q: 为什么有时通道直接BROKEN？
  A: 只要beta≤0（不是上升通道）或回归R²太低（趋势不可靠），或通道宽度过窄/过宽，都会直接BROKEN。
- Q: 还能做下降通道吗？
  A: 不能，本模块只做上升通道。
- Q: fit_channel_history也是一样的规则吗？
  A: 是的，历史批量计算严格用同样的pivot_low+过滤逻辑。

## 【v0.2补充】配置文件示例

```yaml
ascending_channel:
  k: 2.0
  L_max: 120
  delta_cut: 5
  pivot_m: 3
  gain_trigger: 0.30
  beta_delta: 0.15
  break_days: 3
  reanchor_fail_max: 2
  min_data_points: 60
  R2_min: 0.20
  width_pct_min: 0.04
  width_pct_max: 0.12
```

---

# 其余原有内容保留，供API/用法参考。 