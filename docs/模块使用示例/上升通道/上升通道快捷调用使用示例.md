# 上升通道快捷调用使用示例

## 📋 概述

在 `backend/utils/indicators.py` 中新增了上升通道回归分析的快捷调用方法，让您可以像使用其他技术指标一样简单地调用上升通道分析功能。

## 🚀 快速开始

### 基本使用

```python
import pandas as pd
from backend.utils.indicators import CalIndicators

# 准备数据（必须包含 trade_date, open, high, low, close, volume 列）
df = pd.DataFrame({
    'trade_date': [...],  # 日期序列
    'open': [...],        # 开盘价
    'high': [...],        # 最高价
    'low': [...],         # 最低价
    'close': [...],       # 收盘价
    'volume': [...]       # 成交量
})

# 计算上升通道回归分析
channel_info = CalIndicators.ascending_channel(df)
l
# 查看结果
print(f"斜率: {channel_info['beta']:.4f}")
print(f"今日中轴: {channel_info['mid_today']:.2f}")
print(f"今日上沿: {channel_info['upper_today']:.2f}")
print(f"今日下沿: {channel_info['lower_today']:.2f}")
print(f"通道状态: {channel_info['channel_status']}")
print(f"累计涨幅: {channel_info['cumulative_gain']:.2%}")
```

### 使用自定义配置

```python
# 使用自定义配置文件
custom_config_path = "path/to/custom_config.yaml"
channel_info = CalIndicators.ascending_channel(df, config_path=custom_config_path)
```

## 📊 返回结果说明

### 通道信息字典

```python
{
    "beta": 0.0427,              # 最新斜率 beta_t
    "mid_today": 34.89,          # 今日中轴价
    "upper_today": 36.51,        # 今日上沿价
    "lower_today": 33.28,        # 今日下沿价
    "mid_tomorrow": 34.93,       # 预估下一交易日中轴价
    "upper_tomorrow": 36.55,     # 预估下一交易日上沿价
    "lower_tomorrow": 33.31,     # 预估下一交易日下沿价
    "channel_status": "NORMAL",  # 通道状态
    "anchor_date": "2024-01-15T00:00:00",  # 锚点日期
    "anchor_price": 30.50,       # 锚点价格
    "break_cnt_up": 0,           # 连续突破上沿次数
    "break_cnt_down": 0,         # 连续突破下沿次数
    "reanchor_fail_up": 0,       # 重锚失败次数（上沿）
    "reanchor_fail_down": 0,     # 重锚失败次数（下沿）
    "cumulative_gain": 0.1575,   # 累计涨幅
    "last_update": "2024-12-19T00:00:00"  # 最后更新时间
}
```

### 通道状态说明

| 状态 | 描述 | 含义 |
|------|------|------|
| `NORMAL` | 通道正常 | 价格在通道内正常波动 |
| `ACCEL_BREAKOUT` | 加速突破 | 连续突破上沿，可能进入加速上涨 |
| `BREAKDOWN` | 跌破下沿 | 连续跌破下沿，趋势可能反转 |
| `BROKEN` | 通道失效 | 通道已失效，需要重新建立 |

## 🔧 高级功能

### 批量计算

```python
# 准备多个数据集
df_list = [df1, df2, df3, ...]  # 多个DataFrame的列表

# 批量计算上升通道
results = CalIndicators.ascending_channel_batch(df_list)

# 处理结果
for i, result in enumerate(results):
    if result:
        print(f"数据集 {i+1}: 斜率={result['beta']:.4f}, 状态={result['channel_status']}")
    else:
        print(f"数据集 {i+1}: 计算失败")
```

### 与其他指标结合使用

```python
# 计算多个指标
macd, macd_signal, macd_hist = CalIndicators.macd(df)
rsi = CalIndicators.rsi(df)
channel_info = CalIndicators.ascending_channel(df)

# 综合分析
if (channel_info['channel_status'] == 'NORMAL' and 
    channel_info['beta'] > 0.02 and  # 斜率大于2%
    rsi.iloc[-1] < 70 and           # RSI不过热
    macd.iloc[-1] > macd_signal.iloc[-1]):  # MACD金叉
    
    print("符合买入条件")
```

## 📈 实际应用场景

### 1. 策略扫描

```python
def scan_ascending_channels(stock_list):
    """扫描上升通道股票"""
    results = []
    
    for stock_code in stock_list:
        try:
            # 获取股票数据
            df = get_stock_data(stock_code, days=252)
            
            # 计算上升通道
            channel_info = CalIndicators.ascending_channel(df)
            
            # 筛选符合条件的股票
            if (channel_info['channel_status'] == 'NORMAL' and 
                channel_info['beta'] > 0.02 and  # 斜率大于2%
                channel_info['cumulative_gain'] > 0.1):  # 累计涨幅大于10%
                
                results.append({
                    'code': stock_code,
                    'beta': channel_info['beta'],
                    'gain': channel_info['cumulative_gain'],
                    'status': channel_info['channel_status'],
                    'upper': channel_info['upper_today'],
                    'lower': channel_info['lower_today']
                })
                
        except Exception as e:
            print(f"分析股票 {stock_code} 失败: {e}")
    
    return results
```

### 2. 风险监控

```python
def monitor_channel_risk(df):
    """监控通道风险"""
    channel_info = CalIndicators.ascending_channel(df)
    
    risk_level = "LOW"
    risk_reasons = []
    
    # 检查各种风险信号
    if channel_info['channel_status'] == 'BREAKDOWN':
        risk_level = "HIGH"
        risk_reasons.append("跌破通道下沿")
    
    if channel_info['break_cnt_down'] >= 2:
        risk_level = "MEDIUM"
        risk_reasons.append("连续跌破下沿")
    
    if channel_info['cumulative_gain'] > 0.5:
        risk_level = "MEDIUM"
        risk_reasons.append("累计涨幅过大")
    
    return {
        'risk_level': risk_level,
        'reasons': risk_reasons,
        'channel_info': channel_info
    }
```

### 3. 交易信号生成

```python
def generate_trading_signals(df):
    """生成交易信号"""
    channel_info = CalIndicators.ascending_channel(df)
    current_price = df['close'].iloc[-1]
    
    signals = []
    
    # 买入信号
    if (channel_info['channel_status'] == 'ACCEL_BREAKOUT' and
        current_price > channel_info['upper_today']):
        signals.append({
            'type': 'BUY',
            'reason': '加速突破上沿',
            'price': current_price,
            'target': channel_info['upper_tomorrow']
        })
    
    # 卖出信号
    elif (channel_info['channel_status'] == 'BREAKDOWN' and
          current_price < channel_info['lower_today']):
        signals.append({
            'type': 'SELL',
            'reason': '跌破下沿',
            'price': current_price,
            'stop_loss': channel_info['lower_tomorrow']
        })
    
    return signals
```

## ⚠️ 注意事项

### 数据要求

1. **必需列**: 数据必须包含 `trade_date`, `open`, `high`, `low`, `close`, `volume` 列
2. **数据长度**: 至少需要60个交易日的数据
3. **数据质量**: 确保数据按时间排序，无缺失值
4. **数据格式**: 日期列应为 `datetime` 类型，价格列应为数值类型

### 错误处理

```python
try:
    channel_info = CalIndicators.ascending_channel(df)
    # 处理结果
except ImportError as e:
    print("上升通道模块不可用，请检查安装")
except ValueError as e:
    print(f"数据格式错误: {e}")
except Exception as e:
    print(f"计算失败: {e}")
```

### 性能优化

```python
# 对于大量数据，建议使用批量计算
df_list = [df1, df2, df3, ...]
results = CalIndicators.ascending_channel_batch(df_list)

# 或者并行处理
import concurrent.futures

def process_single_df(df):
    return CalIndicators.ascending_channel(df)

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(process_single_df, df_list))
```

## 🔍 调试技巧

### 检查模块可用性

```python
from backend.utils.indicators import ASCENDING_CHANNEL_AVAILABLE

if ASCENDING_CHANNEL_AVAILABLE:
    print("上升通道模块可用")
else:
    print("上升通道模块不可用")
```

### 验证数据格式

```python
def validate_data(df):
    """验证数据格式"""
    required_columns = ['trade_date', 'open', 'high', 'low', 'close', 'volume']
    
    # 检查必需列
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        print(f"缺少必需列: {missing_columns}")
        return False
    
    # 检查数据长度
    if len(df) < 60:
        print(f"数据不足，需要至少60条，当前只有{len(df)}条")
        return False
    
    # 检查数据类型
    if not pd.api.types.is_datetime64_any_dtype(df['trade_date']):
        print("日期列格式不正确")
        return False
    
    return True
```

## 📝 完整示例

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from backend.utils.indicators import CalIndicators

# 生成示例数据
def generate_sample_data(n_days=100):
    dates = pd.date_range('2023-01-01', periods=n_days, freq='D')
    
    # 生成上升趋势数据
    base_trend = np.linspace(10, 50, n_days)
    noise = np.random.normal(0, 1, n_days)
    prices = base_trend + noise
    
    data = []
    for i, (date, price) in enumerate(zip(dates, prices)):
        data.append({
            'trade_date': date,
            'open': price * (1 + np.random.uniform(-0.02, 0.02)),
            'high': price * (1 + np.random.uniform(0.01, 0.05)),
            'low': price * (1 - np.random.uniform(0.01, 0.05)),
            'close': price,
            'volume': np.random.randint(1000000, 10000000)
        })
    
    return pd.DataFrame(data)

# 主程序
def main():
    # 生成数据
    df = generate_sample_data(120)
    
    # 计算上升通道
    channel_info = CalIndicators.ascending_channel(df)
    
    # 输出结果
    print("=== 上升通道分析结果 ===")
    print(f"斜率: {channel_info['beta']:.4f}")
    print(f"今日中轴: {channel_info['mid_today']:.2f}")
    print(f"今日上沿: {channel_info['upper_today']:.2f}")
    print(f"今日下沿: {channel_info['lower_today']:.2f}")
    print(f"明日预测中轴: {channel_info['mid_tomorrow']:.2f}")
    print(f"通道状态: {channel_info['channel_status']}")
    print(f"累计涨幅: {channel_info['cumulative_gain']:.2%}")
    print(f"锚点日期: {channel_info['anchor_date']}")
    print(f"锚点价格: {channel_info['anchor_price']:.2f}")

if __name__ == "__main__":
    main()
```

## 🌐 前端页面集成

### 数据查看器集成

上升通道功能已成功集成到 `pages/data_viewer.py` 前端页面中，用户可以通过以下方式使用：

#### 1. 启用上升通道功能

在数据查看器的侧边栏中，勾选"显示上升通道"选项即可启用该功能。

#### 2. 功能特性

- **可视化显示**: 在K线图上绘制上升通道的中轴线、上沿线、下沿线和锚点
- **实时计算**: 获取数据时自动计算最新的上升通道信息
- **详细信息**: 显示斜率、通道状态、今日价格、累计涨幅等关键指标
- **交互体验**: 鼠标悬停显示详细的通道信息

#### 3. 图表元素说明

| 元素 | 颜色 | 样式 | 说明 |
|------|------|------|------|
| 中轴线 | 橙色 | 实线 | 通道的中心趋势线 |
| 上沿线 | 红色 | 虚线 | 通道的上边界 |
| 下沿线 | 绿色 | 虚线 | 通道的下边界 |
| 锚点 | 橙色 | 菱形标记 | 通道的起始点 |

#### 4. 绘制逻辑说明

**中轴线绘制：**
- 基于 `mid_today` 和 `mid_tomorrow` 两点计算斜率
- 从 `mid_today` 开始，使用计算出的斜率绘制直线
- 公式：`中轴价格 = mid_today + β × 相对天数`
- **重要**：中轴线是回归线本身，不一定会穿过锚点

**上沿线绘制：**
- 保持与中轴线相同的斜率
- 从 `upper_today` 开始绘制
- 公式：`上沿价格 = upper_today + β × 相对天数`

**下沿线绘制：**
- 保持与中轴线相同的斜率
- 从 `lower_today` 开始绘制
- 公式：`下沿价格 = lower_today + β × 相对天数`

**相对天数计算：**
- 今日对应的相对天数为0
- 历史日期为负数（-1, -2, -3...）
- 未来日期为正数（1, 2, 3...）

**回归线计算：**
- 使用从锚点开始的所有数据点进行线性回归
- 回归线公式：`y = intercept + slope × x`
- 中轴线使用回归线的真实参数，而不是强制从锚点开始
- 锚点是最低价，中轴线通常高于锚点

**通道宽度：**
- 整个通道的宽度保持一致
- 上沿和下沿与中轴的距离恒定
- 确保通道的平行性

#### 5. 使用步骤

1. 在侧边栏输入股票代码（如：000001）
2. 选择数据周期（日线/周线/月线）
3. 设置日期范围
4. 勾选"显示上升通道"选项
5. 点击"获取数据"按钮
6. 查看K线图上的上升通道线和相关信息面板

#### 6. 信息面板

启用上升通道后，页面会显示一个专门的"📈 上升通道信息"面板，包含：

- **斜率**: 通道的上升斜率
- **通道状态**: 当前通道状态（NORMAL/ACCEL_BREAKOUT/BREAKDOWN/BROKEN）
- **今日中轴**: 今日通道中轴价格
- **今日上沿**: 今日通道上沿价格
- **今日下沿**: 今日通道下沿价格
- **累计涨幅**: 从锚点开始的累计涨幅
- **锚点价格**: 通道起始价格
- **锚点日期**: 通道起始日期

#### 7. 详细信息

点击"📊 详细通道信息"展开面板可以查看完整的通道信息JSON数据，包括：

- 所有通道参数
- 突破计数器
- 重锚失败次数
- 预测价格等

#### 8. 操作说明

在图表操作说明中新增了上升通道相关的说明：

- 上升通道悬停显示：中轴、上沿、下沿价格和通道状态
- 通道状态说明：各种状态的含义和判断标准
- 图表元素说明：各种线条和标记的含义

### 技术实现

#### 1. 数据流程

```
用户输入 → 获取股票数据 → 计算上升通道 → 绘制通道线 → 显示信息面板
```

#### 2. 关键代码

```python
# 在侧边栏添加选项
show_ascending_channel = st.checkbox('显示上升通道', value=False)

# 计算上升通道
if show_ascending_channel:
    channel_info = CalIndicators.ascending_channel(df_for_calc)
    st.session_state.ascending_channel_info = channel_info

# 绘制通道线
if show_ascending_channel and ascending_channel_info:
    # 获取关键参数
    mid_today = ascending_channel_info.get('mid_today')
    mid_tomorrow = ascending_channel_info.get('mid_tomorrow')
    upper_today = ascending_channel_info.get('upper_today')
    lower_today = ascending_channel_info.get('lower_today')
    
    # 计算斜率（基于mid_today和mid_tomorrow）
    beta = (mid_tomorrow - mid_today) / 1  # 1天的差值
    
    # 计算上沿和下沿的起始点
    days_to_today = (latest_date - anchor_date).days
    upper_anchor = upper_today - beta * days_to_today
    lower_anchor = lower_today - beta * days_to_today
    
    # 绘制中轴线、上沿线、下沿线和锚点
    # 添加悬停文本和交互功能
```

#### 3. 绘制算法

**斜率计算：**
```python
beta = (mid_tomorrow - mid_today) / days_diff
```

**相对天数计算：**
```python
days_relative_to_today = [days - days_to_today for days in days_since_anchor]
# 确保今日对应的相对天数为0
if days_relative_to_today and days_relative_to_today[-1] != 0:
    today_index = len(days_relative_to_today) - 1
    days_relative_to_today = [i - today_index for i in range(len(days_relative_to_today))]
```

**中轴线计算：**
```python
mid_prices = [mid_today + beta * days_rel for days_rel in days_relative_to_today]
```

**上沿线计算：**
```python
upper_prices = [upper_today + beta * days_rel for days_rel in days_relative_to_today]
```

**下沿线计算：**
```python
lower_prices = [lower_today + beta * days_rel for days_rel in days_relative_to_today]
```

#### 4. 错误处理

- 数据不足时显示错误信息
- 计算失败时提供友好的错误提示
- 模块不可用时给出安装建议

---

**最后更新**: 2025年1月29日  
**版本**: v1.1  
**新增功能**: 前端页面集成支持 