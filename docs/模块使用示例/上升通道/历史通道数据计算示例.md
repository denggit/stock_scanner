# 历史通道数据计算示例

## 📋 概述

历史通道数据计算功能可以计算股票在每个历史时点的上升通道状态，为回测分析、策略研究提供完整的时间序列数据。

**核心特点：**

- ✅ **状态连续性**：每个时点基于前一时点状态更新，保持通道连续性
- ✅ **重锚机制**：支持动态重锚，适应市场变化
- ✅ **增量更新**：支持基于历史结果添加新数据，避免重新计算
- ✅ **高效计算**：支持步长计算，提高大数据量处理效率
- ✅ **友好输出**：减少不必要的错误日志，为数据不足时点保留记录（通道数据填None）
- ✅ **完整覆盖**：所有时点都有记录，便于时间序列分析

## 🚀 快速开始

### 基本使用

```python
import datetime
from backend.data.data_fetcher import StockDataFetcher
from backend.utils.indicators import CalIndicators

# 获取股票数据
fetcher = StockDataFetcher()
df = fetcher.fetch_stock_data('sh.600900',
                              start_date=(datetime.date.today() - datetime.timedelta(days=1000)).strftime("%Y-%m-%d"))
df = df[['trade_date', 'open', 'high', 'low', 'close', 'volume']].copy()

# 计算历史通道数据（逐日计算）
history_df = CalIndicators.ascending_channel_history(df, min_window_size=60)

# 查看结果
print(f"历史通道数据计算完成，共{len(history_df)}条记录")
print(history_df[['trade_date', 'close', 'beta', 'mid_today', 'upper_today', 'lower_today', 'channel_status']].tail(10))
print(history_df[['trade_date', 'beta', 'channel_status', 'anchor_date', 'window_size']])
```

### 优化版本（按步长计算）

```python
# 按5天步长计算，提高效率
history_df = CalIndicators.ascending_channel_history_optimized(
    df,
    min_window_size=60,
    step_days=5
)

# 查看结果
print(f"优化历史通道数据计算完成，共{len(history_df)}条记录")
print(history_df[['trade_date', 'close', 'beta', 'mid_today', 'channel_status']].head())
```

## 🔄 增量更新功能

### 为什么需要增量更新？

当您有新的交易日数据时，不需要重新计算整个历史通道，可以使用增量更新功能：

```python
# 假设您已经有了历史通道数据
history_df = CalIndicators.ascending_channel_history(df, min_window_size=60)

# 获取新的一天数据
new_data = pd.DataFrame({
    'trade_date': ['2025-07-19'],
    'open': [38.80],
    'high': [39.20],
    'low': [38.50],
    'close': [38.95],
    'volume': [1000000]
})

# 增量更新（基于DataFrame）
updated_df = CalIndicators.ascending_channel_history_incremental(history_df, new_data)

print(f"更新前: {len(history_df)}条记录")
print(f"更新后: {len(updated_df)}条记录")
print(f"新增: {len(updated_df) - len(history_df)}条记录")
```

### 增量更新的优势

1. **性能提升**：避免重新计算历史数据，大幅提升效率
2. **状态保持**：保持通道状态的连续性，不会丢失历史状态
3. **实时更新**：支持每日实时更新，适合实时交易系统
4. **内存友好**：不需要保存大量历史数据，节省内存

### 增量更新使用场景

```python
# 场景1：每日更新
def daily_update(history_df, new_day_data):
    """每日更新历史通道数据"""
    return CalIndicators.ascending_channel_history_incremental(history_df, new_day_data)


# 场景2：批量更新
def batch_update(history_df, new_batch_data):
    """批量更新多天数据"""
    return CalIndicators.ascending_channel_history_incremental(history_df, new_batch_data)


# 场景3：实时交易系统
class RealTimeChannelTracker:
    def __init__(self, initial_history_df):
        self.history_df = initial_history_df

    def update_with_new_bar(self, new_bar):
        """实时更新单个K线数据"""
        new_data = pd.DataFrame([new_bar])
        self.history_df = CalIndicators.ascending_channel_history_incremental(
            self.history_df, new_data
        )
        return self.history_df.iloc[-1]  # 返回最新状态
```

## 📊 输出数据说明

### 历史通道DataFrame列说明

| 列名 | 类型 | 说明 |
|------|------|------|
| `trade_date` | datetime | 交易日期 |
| `close` | float | 收盘价 |
| `beta` | float | 通道斜率 |
| `sigma` | float | 回归标准差 |
| `mid_today` | float | 当日中轴价 |
| `upper_today` | float | 当日上沿价 |
| `lower_today` | float | 当日下沿价 |
| `mid_tomorrow` | float | 明日预测中轴价 |
| `upper_tomorrow` | float | 明日预测上沿价 |
| `lower_tomorrow` | float | 明日预测下沿价 |
| `channel_status` | str | 通道状态 |
| `anchor_date` | datetime | 锚点日期 |
| `anchor_price` | float | 锚点价格 |
| `break_cnt_up` | int | 连续突破上沿次数 |
| `break_cnt_down` | int | 连续突破下沿次数 |
| `reanchor_fail_up` | int | 重锚失败次数（上沿） |
| `reanchor_fail_down` | int | 重锚失败次数（下沿） |
| `cumulative_gain` | float | 累计涨幅 |
| `window_size` | int | 窗口大小 |
| `days_since_anchor` | int | 距离锚点天数 |

## 🔧 高级功能

### 1. 通道状态分析

```python
# 分析通道状态分布
status_counts = history_df['channel_status'].value_counts()
print("通道状态分布:")
print(status_counts)

# 分析斜率变化
beta_stats = history_df['beta'].describe()
print("斜率统计:")
print(beta_stats)
```

### 2. 通道突破分析

```python
# 找出突破上沿的时点
breakout_up = history_df[history_df['break_cnt_up'] > 0]
print(f"突破上沿次数: {len(breakout_up)}")

# 找出跌破下沿的时点
breakout_down = history_df[history_df['break_cnt_down'] > 0]
print(f"跌破下沿次数: {len(breakout_down)}")
```

### 3. 通道有效性分析

```python
# 计算价格在通道内的比例
def calculate_channel_accuracy(row):
    """计算价格是否在通道内"""
    if row['close'] >= row['lower_today'] and row['close'] <= row['upper_today']:
        return 1
    return 0


history_df['in_channel'] = history_df.apply(calculate_channel_accuracy, axis=1)
accuracy = history_df['in_channel'].mean()
print(f"价格在通道内的比例: {accuracy:.2%}")
```

## 📈 实际应用场景

### 1. 回测分析

```python
def backtest_channel_strategy(history_df):
    """基于历史通道数据的回测策略"""
    signals = []

    for i in range(1, len(history_df)):
        prev_row = history_df.iloc[i - 1]
        curr_row = history_df.iloc[i]

        # 买入信号：突破上沿
        if (prev_row['break_cnt_up'] == 0 and curr_row['break_cnt_up'] == 1 and
                curr_row['channel_status'] == 'NORMAL'):
            signals.append({
                'date': curr_row['trade_date'],
                'action': 'BUY',
                'price': curr_row['close'],
                'reason': '突破上沿'
            })

        # 卖出信号：跌破下沿
        elif (prev_row['break_cnt_down'] == 0 and curr_row['break_cnt_down'] == 1 and
              curr_row['channel_status'] == 'NORMAL'):
            signals.append({
                'date': curr_row['trade_date'],
                'action': 'SELL',
                'price': curr_row['close'],
                'reason': '跌破下沿'
            })

    return pd.DataFrame(signals)


# 执行回测
signals_df = backtest_channel_strategy(history_df)
print("交易信号:")
print(signals_df)
```

### 2. 通道质量评估

```python
def evaluate_channel_quality(history_df):
    """评估通道质量"""
    # 计算通道宽度稳定性
    channel_width = history_df['upper_today'] - history_df['lower_today']
    width_cv = channel_width.std() / channel_width.mean()

    # 计算斜率稳定性
    beta_cv = history_df['beta'].std() / abs(history_df['beta'].mean())

    # 计算价格在通道内的比例
    accuracy = history_df['in_channel'].mean()

    return {
        'width_cv': width_cv,
        'beta_cv': beta_cv,
        'accuracy': accuracy,
        'total_points': len(history_df)
    }


quality = evaluate_channel_quality(history_df)
print("通道质量评估:")
for key, value in quality.items():
    print(f"{key}: {value:.4f}")
```

### 3. 批量股票分析

```python
def analyze_multiple_stocks(stock_codes):
    """批量分析多只股票的通道数据"""
    results = {}

    for code in stock_codes:
        try:
            # 获取数据
            df = fetcher.fetch_stock_data(code)
            df = df[['trade_date', 'open', 'high', 'low', 'close', 'volume']].copy()

            # 计算历史通道
            history_df = CalIndicators.ascending_channel_history_optimized(
                df, min_window_size=60, step_days=5
            )

            # 评估质量
            quality = evaluate_channel_quality(history_df)
            results[code] = quality

        except Exception as e:
            print(f"分析股票 {code} 失败: {e}")

    return pd.DataFrame(results).T


# 批量分析
stock_codes = ['sz.301383', 'sz.000001', 'sh.600000']
results_df = analyze_multiple_stocks(stock_codes)
print("批量分析结果:")
print(results_df)
```

### 4. 实时监控系统

```python
class ChannelMonitor:
    """实时通道监控系统"""

    def __init__(self, stock_code, min_window_size=60):
        self.stock_code = stock_code
        self.min_window_size = min_window_size
        self.history_df = None
        self.fetcher = StockDataFetcher()

    def initialize(self):
        """初始化历史数据"""
        df = self.fetcher.fetch_stock_data(self.stock_code)
        df = df[['trade_date', 'open', 'high', 'low', 'close', 'volume']].copy()
        self.history_df = CalIndicators.ascending_channel_history(
            df, min_window_size=self.min_window_size
        )
        print(f"初始化完成，历史数据长度: {len(self.history_df)}")

    def update_daily(self, new_data):
        """每日更新"""
        if self.history_df is None:
            raise ValueError("请先调用 initialize() 方法")

        self.history_df = CalIndicators.ascending_channel_history_incremental(
            self.history_df, new_data
        )

        # 获取最新状态
        latest = self.history_df.iloc[-1]

        # 检查信号
        signals = []
        if latest['break_cnt_up'] == 1:
            signals.append("突破上沿")
        if latest['break_cnt_down'] == 1:
            signals.append("跌破下沿")
        if latest['channel_status'] != 'NORMAL':
            signals.append(f"通道状态异常: {latest['channel_status']}")

        return {
            'date': latest['trade_date'],
            'close': latest['close'],
            'beta': latest['beta'],
            'mid_today': latest['mid_today'],
            'upper_today': latest['upper_today'],
            'lower_today': latest['lower_today'],
            'channel_status': latest['channel_status'],
            'signals': signals
        }


# 使用示例
monitor = ChannelMonitor('sz.301383')
monitor.initialize()

# 模拟每日更新
new_day_data = pd.DataFrame({
    'trade_date': ['2025-07-19'],
    'open': [38.80],
    'high': [39.20],
    'low': [38.50],
    'close': [38.95],
    'volume': [1000000]
})

status = monitor.update_daily(new_day_data)
print("今日状态:", status)
```

## ⚠️ 注意事项

### 性能优化

1. **步长设置**: 对于大量数据，建议使用 `step_days=5` 或 `step_days=10` 提高计算效率
2. **窗口大小**: `min_window_size` 建议设置为60-120天，平衡精度和效率
3. **数据质量**: 确保输入数据按时间排序，无缺失值
4. **增量更新**: 对于频繁更新的场景，优先使用增量更新功能

### 数据要求

1. **最小数据量**: 至少需要 `min_window_size + 20` 个数据点
2. **必需列**: `trade_date`, `open`, `high`, `low`, `close`, `volume`
3. **时间格式**: `trade_date` 应为 `datetime` 类型
4. **增量更新**: 新数据的时间必须晚于历史数据的最后时间

### 异常处理

```python
try:
    history_df = CalIndicators.ascending_channel_history(df)
    # 处理结果
except InsufficientDataError as e:
    print(f"数据不足: {e}")
except Exception as e:
    print(f"计算失败: {e}")

# 增量更新异常处理
try:
    updated_df = CalIndicators.ascending_channel_history_incremental(history_df, new_data)
    # 处理更新结果
except ValueError as e:
    print(f"增量更新失败: {e}")
    # 回退到完整计算
    full_df = CalIndicators.ascending_channel_history(combined_df)
```

### 数据不足时点的处理

历史通道计算会为所有时点保留记录，即使某些时点数据不足无法计算通道：

```python
# 查看数据不足的时点
invalid_records = history_df[history_df['beta'].isna()]
print(f"数据不足的时点数: {len(invalid_records)}")

# 查看有效通道记录
valid_records = history_df[history_df['beta'].notna()]
print(f"有效通道记录数: {len(valid_records)}")

# 数据不足时点的示例
print("数据不足时点示例:")
print(invalid_records[['trade_date', 'close', 'beta', 'channel_status']].head())
```

**输出示例：**

```
数据不足的时点数: 2
有效通道记录数: 179
数据不足时点示例:
   trade_date  close  beta channel_status
0 2024-10-23  34.86   NaN           None
1 2024-10-24  34.69   NaN           None
```

**特点：**

- 数据不足时点保留 `trade_date` 和 `close` 信息
- 通道相关字段（`beta`, `mid_today`, `upper_today`, `lower_today` 等）填充为 `None`
- `channel_status` 为 `None`
- 便于后续分析和可视化

## 📝 完整示例

```python
import pandas as pd
import numpy as np
from backend.data.data_fetcher import StockDataFetcher
from backend.utils.indicators import CalIndicators


def main():
    # 获取数据
    fetcher = StockDataFetcher()
    df = fetcher.fetch_stock_data('sz.301383')
    df = df[['trade_date', 'open', 'high', 'low', 'close', 'volume']].copy()

    # 计算历史通道数据
    history_df = CalIndicators.ascending_channel_history_optimized(
        df, min_window_size=60, step_days=5
    )

    # 分析结果
    print("=== 历史通道分析结果 ===")
    print(f"总计算时点: {len(history_df)}")
    print(f"时间范围: {history_df['trade_date'].min()} 到 {history_df['trade_date'].max()}")

    # 通道状态分布
    print("\n通道状态分布:")
    print(history_df['channel_status'].value_counts())

    # 斜率统计
    print("\n斜率统计:")
    print(history_df['beta'].describe())

    # 最新通道信息
    latest = history_df.iloc[-1]
    print(f"\n最新通道信息 ({latest['trade_date']}):")
    print(f"收盘价: {latest['close']:.2f}")
    print(f"斜率: {latest['beta']:.4f}")
    print(f"中轴: {latest['mid_today']:.2f}")
    print(f"上沿: {latest['upper_today']:.2f}")
    print(f"下沿: {latest['lower_today']:.2f}")
    print(f"通道状态: {latest['channel_status']}")

    # 增量更新示例
    print("\n=== 增量更新示例 ===")
    new_data = pd.DataFrame({
        'trade_date': ['2025-07-19', '2025-07-20'],
        'open': [38.80, 38.95],
        'high': [39.20, 39.50],
        'low': [38.50, 38.80],
        'close': [38.95, 39.30],
        'volume': [1000000, 1200000]
    })

    updated_df = CalIndicators.ascending_channel_history_incremental(history_df, new_data)
    print(f"增量更新后总记录数: {len(updated_df)}")
    print(f"新增记录数: {len(updated_df) - len(history_df)}")

    return history_df, updated_df


if __name__ == "__main__":
    history_df, updated_df = main()
```

---

**最后更新**: 2024年12月19日  
**版本**: v2.0  
**新增功能**: 增量更新、实时监控、批量分析

### 自定义参数使用

所有方法都支持通过 `**params` 参数自定义配置，覆盖配置文件中的默认参数：

```python
# 使用自定义参数计算上升通道
custom_params = {
    'k': 2.5,  # 通道宽度倍数
    'L_max': 100,  # 最大窗口长度
    'gain_trigger': 0.4,  # 重锚涨幅触发阈值
    'break_days': 5,  # 连续突破天数
    'pivot_m': 5  # 锚点检测参数
}

# 单次计算
result = CalIndicators.ascending_channel(df, **custom_params)

# 历史通道计算
history_df = CalIndicators.ascending_channel_history(
    df,
    min_window_size=60,
    **custom_params
)

# 优化历史通道计算
history_df = CalIndicators.ascending_channel_history_optimized(
    df,
    min_window_size=60,
    step_days=5,
    **custom_params
)
```

### 支持的参数列表

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `k` | float | 2.0 | 通道宽度倍数，控制通道上下沿的宽度 |
| `L_max` | int | 120 | 最大窗口长度，超过此长度会滑动窗口 |
| `delta_cut` | int | 5 | 滑动窗口删除天数 |
| `pivot_m` | int | 3 | 锚点检测参数，判断pivot的宽度 |
| `gain_trigger` | float | 0.30 | 重锚涨幅触发阈值 |
| `beta_delta` | float | 0.15 | 斜率变化阈值 |
| `break_days` | int | 3 | 连续突破天数 |
| `reanchor_fail_max` | int | 2 | 重锚失败最大次数 |
| `min_data_points` | int | 60 | 最小数据点数 |

### 参数使用示例

```python
# 示例1：调整通道宽度
narrow_channel = CalIndicators.ascending_channel(df, k=1.5)  # 窄通道
wide_channel = CalIndicators.ascending_channel(df, k=3.0)  # 宽通道

# 示例2：调整重锚敏感度
sensitive = CalIndicators.ascending_channel(df, gain_trigger=0.2)  # 更敏感
stable = CalIndicators.ascending_channel(df, gain_trigger=0.5)  # 更稳定

# 示例3：调整窗口长度
short_window = CalIndicators.ascending_channel(df, L_max=60)  # 短窗口
long_window = CalIndicators.ascending_channel(df, L_max=200)  # 长窗口

# 示例4：组合参数
custom_config = {
    'k': 2.5,
    'L_max': 100,
    'gain_trigger': 0.4,
    'break_days': 5,
    'pivot_m': 5
}

result = CalIndicators.ascending_channel(df, **custom_config)
``` 

# 【补充】参数作用与调优建议

## 关键参数说明

| 参数名           | 作用/建议                                                         |
|------------------|-------------------------------------------------------------------|
| min_window_size  | 控制历史通道计算的起点，越小越早尝试，但有效通道起点由数据决定      |
| pivot_m          | 锚点检测灵敏度，越小越容易找到锚点，越大越严格，适合大波动品种      |
| min_data_points  | 最小有效数据点，影响能否找到有效通道，调小可让通道更早出现           |
| k                | 通道宽度倍数，影响通道上下沿宽窄                                   |
| L_max            | 最大窗口长度，影响通道的“记忆”长度                                 |

## 推荐设置

- min_window_size: 60~120（一般不建议小于60，除非数据很短）
- pivot_m: 2~5（小票/高波动可用2，大票/低波动可用3~5）
- min_data_points: 30~60（想让通道更早出现可调小，但会降低稳健性）

---

# 【补充】如何让通道更早出现？

1. **调小pivot_m**：
   ```python
   # 更灵敏的锚点检测
   analyzer = AscendingChannelRegression(pivot_m=1)
   ```
2. **调小min_data_points**：
   ```python
   analyzer = AscendingChannelRegression(min_data_points=20)
   ```
3. **调小min_window_size**：
   ```python
   history_df = CalIndicators.ascending_channel_history(df, min_window_size=10)
   ```
4. **数据本身要有明显趋势**：如果前期数据横盘或波动太小，通道很难早出现。

---

# 【补充】常见误区与调优建议

- 误区1：以为min_window_size越小通道越早出现。实际上，**有效通道起点由数据和锚点参数决定**。
- 误区2：以为所有参数都能随时生效。**只有实例化时传入的参数才会全链路生效**。
- 误区3：以为所有时点都能算出通道。**前期数据不足/找不到锚点时，通道字段会是None**。

**调优建议**：

- 先用默认参数，观察有效通道起点，再逐步调小pivot_m、min_data_points。
- 如果通道太“跳”，可适当增大pivot_m、min_data_points。
- 关注beta、window_size、channel_status等字段，辅助判断通道质量。

---

# 【补充】参数调优对比实验

```python
# 对比不同pivot_m和min_data_points的效果
for m in [1, 2, 3]:
    analyzer = AscendingChannelRegression(pivot_m=m, min_data_points=20)
    history_df = analyzer.fit_channel_history(df, min_window_size=10)
    valid_cnt = history_df['beta'].notna().sum()
    print(f"pivot_m={m}, 有效通道点数: {valid_cnt}")
```

---

# 【补充】异常数据处理与容错机制

- 所有历史时点都会保留一条记录，数据不足/锚点找不到时通道字段为None。
- 增量更新时如遇异常，会自动降级为None并重置状态，保证后续可恢复。
- 建议对history_df做如下检查：
  ```python
  # 检查无效点
  print(history_df[history_df['beta'].isna()][['trade_date','close']].head())
  # 检查有效点
  print(history_df[history_df['beta'].notna()][['trade_date','close','beta']].head())
  ```

---

# 【补充】FAQ与实用场景小结

## Q: 为什么前面几十个点通道都是None？

A: 数据不足/找不到有效锚点/窗口太小，属于正常现象。

## Q: 如何让通道更早出现？

A: 调小pivot_m、min_data_points，或用更有趋势性的数据。

## Q: 为什么min_window_size怎么调都没用？

A: 它只影响循环起点，实际有效通道起点由数据和锚点参数决定。

## Q: 如何批量分析多只股票？

A: 用CalIndicators.ascending_channel_batch(df_list)即可。

## Q: 如何判断通道质量？

A: 关注window_size、beta、channel_status，结合实际走势分析。

---

【如需更详细的调优建议或遇到特殊数据问题，欢迎随时联系开发者！】 