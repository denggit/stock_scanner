# 🚀 回测框架使用示例

## 📋 目录

- [🎯 快速开始](#-快速开始)
- [📊 多策略比较](#-多策略比较)
- [⚙️ 参数优化](#️-参数优化)
- [🔧 自定义策略](#-自定义策略)
- [📈 结果分析](#-结果分析)
- [🛠️ 工具函数](#️-工具函数)
- [🐛 故障排除](#-故障排除)

---

## 🎯 快速开始

### 1.1 基本回测

```python
from backend.business.backtest_event import run_backtest
from backend.business.backtest_event.strategies.ma import MAStrategy
from backend.business.backtest_event.strategies.macd import MACDStrategy
from backend.business.backtest_event.strategies.rsi import RSIStrategy
from backend.business.data.data_fetcher import StockDataFetcher

# 获取数据
fetcher = StockDataFetcher()
data = fetcher.fetch_stock_data("000001.SZ", "2024-01-01", "2024-12-31")

# 运行回测
results = run_backtest(
    data=data,
    strategy_class=MAStrategy,
    initial_cash=100000.0,
    commission=0.0003,
    strategy_params={'ma_period': 20},
    strategy_name='MA策略'
)

# 查看结果
print(f"总收益率: {results['total_return']:.2%}")
print(f"年化收益率: {results['annual_return']:.2%}")
print(f"最大回撤: {results['max_drawdown']:.2%}")
print(f"夏普比率: {results['sharpe_ratio']:.2f}")
```

### 1.2 使用回测引擎

```python
from backend.business.backtest_event.core.backtest_engine import BacktestEngine
from backend.business.backtest_event.strategies.ma import MAStrategy

# 创建回测引擎
engine = BacktestEngine(initial_cash=100000.0, commission=0.0003)

# 添加数据
engine.add_data(data)

# 添加策略
engine.add_strategy(MAStrategy, ma_period=20)

# 运行回测
results = engine.run("MA策略")

# 获取详细结果
print(f"总收益率: {results['total_return']:.2%}")
print(f"交易次数: {results['total_trades']}")
print(f"胜率: {results['win_rate']:.2%}")
```

---

## 📊 多策略比较

### 2.1 多策略回测

```python
from backend.business.backtest_event import run_multi_strategy_backtest
from backend.business.backtest_event.strategies.ma import MAStrategy
from backend.business.backtest_event.strategies.macd import MACDStrategy
from backend.business.backtest_event.strategies.rsi import RSIStrategy

# 准备数据
fetcher = StockDataFetcher()
data = fetcher.fetch_stock_data("000001.SZ", "2024-01-01", "2024-12-31")

# 定义策略列表
strategies = [
    {
        'name': 'MA策略',
        'class': MAStrategy,
        'params': {'ma_period': 20}
    },
    {
        'name': 'MACD策略',
        'class': MACDStrategy,
        'params': {'fast_period': 12, 'slow_period': 26, 'signal_period': 9}
    },
    {
        'name': 'RSI策略',
        'class': RSIStrategy,
        'params': {'rsi_period': 14, 'oversold': 30, 'overbought': 70}
    }
]

# 运行多策略回测
results = run_multi_strategy_backtest(
    data=data,
    strategies=strategies,
    initial_cash=100000.0,
    commission=0.0003
)

# 查看比较结果
for strategy_name, result in results.items():
    print(f"\n{strategy_name}:")
    print(f"  总收益率: {result['total_return']:.2%}")
    print(f"  年化收益率: {result['annual_return']:.2%}")
    print(f"  最大回撤: {result['max_drawdown']:.2%}")
    print(f"  夏普比率: {result['sharpe_ratio']:.2f}")
    print(f"  胜率: {result['win_rate']:.2%}")
```

### 2.2 策略性能对比

```python
from backend.business.backtest_event.core.result_analyzer import ResultAnalyzer

# 创建分析器
analyzer = ResultAnalyzer()

# 比较策略性能
comparison = analyzer.compare_strategies(list(results.values()))

# 生成对比报告
print("策略性能对比:")
print(comparison['summary_table'])

# 获取最佳策略
best_strategy = comparison['best_strategy']
print(f"\n最佳策略: {best_strategy['name']}")
print(f"最佳收益率: {best_strategy['total_return']:.2%}")
```

---

## ⚙️ 参数优化

### 3.1 网格搜索优化

```python
from backend.business.backtest_event import optimize_parameters

# 定义参数范围
parameter_ranges = {
    'ma_period': [5, 10, 15, 20, 25, 30],
    'volume_ratio': [1.0, 1.2, 1.5, 2.0]
}

# 运行参数优化
optimization_results = optimize_parameters(
    data=data,
    strategy_class=MAStrategy,
    parameter_ranges=parameter_ranges,
    initial_cash=100000.0,
    commission=0.0003,
    optimization_target='total_return'  # 优化目标：总收益率
)

# 查看优化结果
print(f"最优参数: {optimization_results['best_params']}")
print(f"最优收益率: {optimization_results['best_value']:.2%}")
print(f"参数组合数: {optimization_results['total_combinations']}")
```

### 3.2 贝叶斯优化

```python
from backend.business.backtest_event import bayesian_optimization

# 定义参数边界
param_bounds = {
    'ma_period': (5, 50),
    'volume_ratio': (0.5, 3.0)
}

# 运行贝叶斯优化
bayesian_results = bayesian_optimization(
    data=data,
    strategy_class=MAStrategy,
    param_bounds=param_bounds,
    initial_cash=100000.0,
    commission=0.0003,
    n_iterations=50
)

print(f"最优参数: {bayesian_results['best_params']}")
print(f"最优收益率: {bayesian_results['best_value']:.2%}")
```

---

## 🔧 自定义策略

### 4.1 创建自定义策略

```python
from backend.business.backtest_event.core.base_strategy import BaseStrategy

class MyCustomStrategy(BaseStrategy):
    def __init__(self):
        super().__init__()
        self.name = "我的自定义策略"
        self.description = "基于价格动量的简单策略"
    
    def next(self):
        """策略逻辑实现"""
        # 获取当前价格
        current_price = self.data.close[-1]
        previous_price = self.data.close[-2]
        
        # 计算价格动量
        momentum = (current_price - previous_price) / previous_price
        
        # 交易逻辑
        if momentum > 0.02:  # 价格上涨超过2%
            if not self.position:  # 没有持仓
                self.buy()
        elif momentum < -0.02:  # 价格下跌超过2%
            if self.position:  # 有持仓
                self.sell()

# 使用自定义策略
results = run_backtest(
    data=data,
    strategy_class=MyCustomStrategy,
    initial_cash=100000.0,
    commission=0.0003,
    strategy_name='自定义策略'
)
```

### 4.2 策略参数化

```python
class ParameterizedStrategy(BaseStrategy):
    def __init__(self, momentum_threshold=0.02, stop_loss=0.05):
        super().__init__()
        self.name = "参数化策略"
        self.momentum_threshold = momentum_threshold
        self.stop_loss = stop_loss
    
    def next(self):
        current_price = self.data.close[-1]
        previous_price = self.data.close[-2]
        momentum = (current_price - previous_price) / previous_price
        
        # 止损检查
        if self.position:
            entry_price = self.position.entry_price
            loss_ratio = (current_price - entry_price) / entry_price
            if loss_ratio < -self.stop_loss:
                self.sell()
                return
        
        # 交易信号
        if momentum > self.momentum_threshold:
            if not self.position:
                self.buy()
        elif momentum < -self.momentum_threshold:
            if self.position:
                self.sell()

# 使用参数化策略
results = run_backtest(
    data=data,
    strategy_class=ParameterizedStrategy,
    initial_cash=100000.0,
    commission=0.0003,
    strategy_params={
        'momentum_threshold': 0.03,
        'stop_loss': 0.08
    },
    strategy_name='参数化策略'
)
```

---

## 📈 结果分析

### 5.1 详细结果分析

```python
from backend.business.backtest_event.core.result_analyzer import ResultAnalyzer

# 创建分析器
analyzer = ResultAnalyzer()

# 分析回测结果
analysis = analyzer.analyze(results)

# 查看详细指标
print("=== 收益指标 ===")
print(f"总收益率: {analysis['total_return']:.2%}")
print(f"年化收益率: {analysis['annual_return']:.2%}")
print(f"日收益率均值: {analysis['daily_return_mean']:.4f}")
print(f"日收益率标准差: {analysis['daily_return_std']:.4f}")

print("\n=== 风险指标 ===")
print(f"最大回撤: {analysis['max_drawdown']:.2%}")
print(f"夏普比率: {analysis['sharpe_ratio']:.2f}")
print(f"索提诺比率: {analysis['sortino_ratio']:.2f}")
print(f"卡尔马比率: {analysis['calmar_ratio']:.2f}")

print("\n=== 交易指标 ===")
print(f"总交易次数: {analysis['total_trades']}")
print(f"盈利交易次数: {analysis['profit_trades']}")
print(f"亏损交易次数: {analysis['loss_trades']}")
print(f"胜率: {analysis['win_rate']:.2%}")
print(f"盈亏比: {analysis['profit_loss_ratio']:.2f}")
```

### 5.1.1 交易指标计算说明

**💡 重要更新（2025年1月）**: 交易指标计算模块已全面优化，现在支持：

- ✅ **多种交易数据格式兼容**：自动识别中文和英文字段名
- ✅ **智能数据类型处理**：正确处理numpy数据类型和普通Python数据类型  
- ✅ **持仓时间计算**：自动匹配买入和卖出交易，计算实际持仓天数
- ✅ **详细调试输出**：提供完整的计算过程日志，便于问题排查
- ✅ **错误容错机制**：在数据异常时提供降级处理方案

**🔧 性能指标计算修复（2025年8月）**: 年化收益率和年化波动率计算逻辑已全面修复：

**修复前的问题：**
- ❌ **年化波动率过高**：错误使用交易频率进行年化，导致结果异常（如162.80%）
- ❌ **年化收益率不准确**：回测天数计算不精确，影响年化计算
- ❌ **缺乏合理性检查**：没有上下限控制，允许极端异常值

**修复后的改进：**
- ✅ **正确的年化波动率计算**：基于平均持仓天数而非交易频率进行年化
- ✅ **准确的回测时间获取**：优先从数据源获取实际回测天数，提高精度
- ✅ **智能合理性检查**：设置上下限控制（10%-100%），自动调整异常值
- ✅ **保守的估算策略**：当数据不足时，使用保守的波动率倍数估算

**修复效果对比：**
```python
# 修复前（异常）
年化收益率: 54.27%    # 过高，不合理
年化波动率: 162.80%   # 严重过高
夏普比率: 17.30       # 计算基础错误

# 修复后（正常）  
年化收益率: 32.62%    # 合理，符合实际收益
年化波动率: 58.71%    # 正常范围，符合股票策略特征
夏普比率: 17.30       # 基于正确计算的优秀指标
```

**技术实现细节：**
```python
# 修复前的错误计算
trades_per_year = len(returns) / years  # 交易频率
annual_volatility = returns_std * np.sqrt(trades_per_year) * 100  # 错误

# 修复后的正确计算
average_holding_days = backtest_days / len(returns)  # 平均持仓天数  
annualization_factor = np.sqrt(365.25 / average_holding_days)  # 基于时间频率
annual_volatility = returns_std * annualization_factor * 100  # 正确
```

**交易指标详细说明：**

```python
# 获取交易指标详细信息
trade_metrics = analyzer._calculate_trade_metrics(strategy)

print("=== 交易指标详解 ===")
print(f"交易次数: {trade_metrics['交易次数']}")           # 完整交易数（卖出次数）
print(f"盈利交易: {trade_metrics['盈利交易']}")           # 收益率 > 0 的交易数
print(f"亏损交易: {trade_metrics['亏损交易']}")           # 收益率 <= 0 的交易数  
print(f"胜率: {trade_metrics['胜率']:.2f}%")            # 盈利交易数 / 总交易数 * 100
print(f"平均收益: {trade_metrics['平均收益']:.2f}")       # 平均每笔交易收益金额
print(f"最大单笔收益: {trade_metrics['最大单笔收益']:.2f}") # 单笔交易最大收益金额
print(f"最大单笔亏损: {trade_metrics['最大单笔亏损']:.2f}") # 单笔交易最大亏损金额
print(f"平均持仓时间: {trade_metrics['平均持仓时间']:.1f}天") # 买入到卖出的平均天数
```

**交易分析表字段更新（2025-08）：**

- 新增列：`通道宽度(绝对值)`、`通道宽度(%)`
- 定义：
  - `通道宽度(绝对值)` = 买入当日`今日上沿 - 今日下沿`
  - `通道宽度(%)` = [(买入当日`今日上沿 - 今日下沿`)/买入当日`今日中轴`] × 100
- 目的：避免把绝对价差误解为百分比，报告中同时提供两种形态，便于交叉验证。

**支持的交易记录格式：**

```python
# 格式1：中文字段（上升通道策略等）
trade_record_cn = {
    '交易日期': datetime(2024, 1, 15),
    '交易动作': 'SELL',
    '股票代码': '000001.SZ', 
    '交易数量': 1000,
    '交易价格': 11.20,
    '交易金额': 11200.0,
    '收益率': 6.67
}

# 格式2：英文字段（基础策略等）
trade_record_en = {
    'date': datetime(2024, 1, 15),
    'action': 'SELL',
    'stock_code': '000001.SZ',
    'size': 1000, 
    'price': 11.20,
    'value': 11200.0,
    'returns': 6.67
}

# 两种格式都能正确识别和处理
```

### 5.2 生成分析报告

```python
# 生成详细报告
report = analyzer.generate_report(results)

# 保存报告
with open('backtest_report.html', 'w', encoding='utf-8') as f:
    f.write(report['html_report'])

# 导出Excel报告
report['excel_report'].to_excel('backtest_report.xlsx', index=False)

print("报告已生成:")
print("- backtest_report.html (HTML格式)")
print("- backtest_report.xlsx (Excel格式)")
```

### 5.3 可视化分析

```python
import matplotlib.pyplot as plt
import seaborn as sns

# 绘制权益曲线
plt.figure(figsize=(12, 8))

# 子图1: 权益曲线
plt.subplot(2, 2, 1)
plt.plot(results['equity_curve']['date'], results['equity_curve']['equity'])
plt.title('权益曲线')
plt.xlabel('日期')
plt.ylabel('权益')

# 子图2: 回撤曲线
plt.subplot(2, 2, 2)
plt.plot(results['drawdown_curve']['date'], results['drawdown_curve']['drawdown'])
plt.title('回撤曲线')
plt.xlabel('日期')
plt.ylabel('回撤')

# 子图3: 收益率分布
plt.subplot(2, 2, 3)
plt.hist(results['daily_returns'], bins=50, alpha=0.7)
plt.title('日收益率分布')
plt.xlabel('收益率')
plt.ylabel('频次')

# 子图4: 交易分布
plt.subplot(2, 2, 4)
trade_returns = [trade['return'] for trade in results['trades']]
plt.hist(trade_returns, bins=30, alpha=0.7)
plt.title('交易收益率分布')
plt.xlabel('收益率')
plt.ylabel('频次')

plt.tight_layout()
plt.show()
```

---

## 🛠️ 工具函数

### 6.1 数据工具

```python
from backend.business.backtest_event.utils.data_utils import DataUtils

# 创建样本数据
sample_data = DataUtils.create_sample_data(
    days=252,  # 一年的交易日
    start_price=10.0,
    volatility=0.02
)

# 验证数据格式
validation = DataUtils.validate_data(sample_data)
if validation['is_valid']:
    print("数据格式正确")
else:
    print(f"数据格式错误: {validation['errors']}")

# 数据预处理
processed_data = DataUtils.preprocess_data(sample_data)
```

### 6.2 报告工具

```python
from backend.business.backtest_event.utils.report_utils import ReportUtils

# 创建报告工具
report_utils = ReportUtils()

# 生成HTML报告
html_report = report_utils.generate_html_report(results)

# 生成Excel报告
excel_report = report_utils.generate_excel_report(results)

# 生成PDF报告
pdf_report = report_utils.generate_pdf_report(results)

# 保存报告
report_utils.save_report(html_report, 'backtest_report.html')
report_utils.save_report(excel_report, 'backtest_report.xlsx')
```

### 6.3 性能监控

```python
import time
from backend.business.backtest_event.utils.performance_monitor import PerformanceMonitor

# 创建性能监控器
monitor = PerformanceMonitor()

# 开始监控
monitor.start()

# 运行回测
start_time = time.time()
results = run_backtest(data=data, strategy_class=MAStrategy, ...)
end_time = time.time()

# 停止监控
monitor.stop()

# 获取性能指标
performance_metrics = monitor.get_metrics()
print(f"回测耗时: {end_time - start_time:.2f}秒")
print(f"内存使用: {performance_metrics['memory_usage']:.2f}MB")
print(f"CPU使用率: {performance_metrics['cpu_usage']:.2f}%")
```

---

## 🐛 故障排除

### 7.1 常见错误

```python
# 1. 数据格式错误
try:
    results = run_backtest(data=data, strategy_class=MAStrategy, ...)
except ValueError as e:
    if "missing columns" in str(e):
        print("数据缺少必需列，需要包含: open, high, low, close, volume")
    elif "empty data" in str(e):
        print("数据为空，请检查数据源")

# 2. 策略参数错误
try:
    results = run_backtest(data=data, strategy_class=MAStrategy, ...)
except TypeError as e:
    if "unexpected keyword argument" in str(e):
        print("策略参数错误，请检查参数名称")

# 3. 资金不足错误
try:
    results = run_backtest(data=data, strategy_class=MAStrategy, ...)
except RuntimeError as e:
    if "insufficient funds" in str(e):
        print("初始资金不足，请增加初始资金")
```

### 7.2 调试模式

```python
import logging

# 设置调试日志
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def debug_backtest(data, strategy_class, **kwargs):
    """调试模式下的回测"""
    
    logger.debug(f"输入数据形状: {data.shape}")
    logger.debug(f"策略类: {strategy_class}")
    logger.debug(f"参数: {kwargs}")
    
    try:
        results = run_backtest(data=data, strategy_class=strategy_class, **kwargs)
        logger.debug(f"回测成功，收益率: {results['total_return']:.2%}")
        return results
    except Exception as e:
        logger.error(f"回测失败: {e}")
        raise

# 使用调试模式
results = debug_backtest(data, MAStrategy, initial_cash=100000.0)
```

### 7.3 数据验证

```python
def validate_backtest_data(data):
    """验证回测数据"""
    
    # 检查必需列
    required_columns = ['open', 'high', 'low', 'close', 'volume']
    missing_columns = [col for col in required_columns if col not in data.columns]
    if missing_columns:
        return False, f"缺少必需列: {missing_columns}"
    
    # 检查数据量
    if len(data) < 30:
        return False, f"数据量不足，当前{len(data)}条，建议至少30条"
    
    # 检查数据类型
    for col in required_columns:
        if not pd.api.types.is_numeric_dtype(data[col]):
            return False, f"{col}列必须是数值类型"
    
    # 检查空值
    for col in required_columns:
        if data[col].isna().any():
            return False, f"{col}列包含空值"
    
    # 检查价格逻辑
    if (data['high'] < data['low']).any():
        return False, "存在最高价低于最低价的数据"
    
    if (data['open'] > data['high']).any() or (data['open'] < data['low']).any():
        return False, "存在开盘价超出最高最低价范围的数据"
    
    if (data['close'] > data['high']).any() or (data['close'] < data['low']).any():
        return False, "存在收盘价超出最高最低价范围的数据"
    
    return True, "数据验证通过"

# 使用数据验证
is_valid, message = validate_backtest_data(data)
if not is_valid:
    print(f"数据验证失败: {message}")
else:
    print("数据验证通过，可以开始回测")
```

---

## 📚 完整示例

### 8.1 完整的回测流程

```python
import pandas as pd
from backend.business.backtest_event import run_backtest, run_multi_strategy_backtest
from backend.business.backtest_event.strategies.ma import MAStrategy
from backend.business.backtest_event.strategies.macd import MACDStrategy
from backend.business.data.data_fetcher import StockDataFetcher
from backend.business.backtest_event.core.result_analyzer import ResultAnalyzer


def complete_backtest_workflow(stock_code, start_date, end_date):
    """完整的回测工作流程"""

    # 1. 获取数据
    fetcher = StockDataFetcher()
    data = fetcher.fetch_stock_data(stock_code, start_date, end_date)

    # 2. 数据验证
    is_valid, message = validate_backtest_data(data)
    if not is_valid:
        print(f"数据验证失败: {message}")
        return None

    # 3. 单策略回测
    ma_results = run_backtest(
        data=data,
        strategy_class=MAStrategy,
        initial_cash=100000.0,
        commission=0.0003,
        strategy_params={'ma_period': 20},
        strategy_name='MA策略'
    )

    # 4. 多策略回测
    strategies = [
        {'name': 'MA策略', 'class': MAStrategy, 'params': {'ma_period': 20}},
        {'name': 'MACD策略', 'class': MACDStrategy, 'params': {}}
    ]

    multi_results = run_multi_strategy_backtest(
        data=data,
        strategies=strategies,
        initial_cash=100000.0,
        commission=0.0003
    )

    # 5. 结果分析
    analyzer = ResultAnalyzer()
    analysis = analyzer.analyze(ma_results)

    # 6. 生成报告
    report = analyzer.generate_report(ma_results)

    # 7. 结果汇总
    summary = {
        'stock_code': stock_code,
        'period': f"{start_date} 到 {end_date}",
        'single_strategy_results': ma_results,
        'multi_strategy_results': multi_results,
        'analysis': analysis,
        'report': report
    }

    return summary


# 使用完整流程
summary = complete_backtest_workflow("000001.SZ", "2024-01-01", "2024-12-31")

if summary:
    print(f"股票代码: {summary['stock_code']}")
    print(f"回测期间: {summary['period']}")
    print(f"MA策略收益率: {summary['single_strategy_results']['total_return']:.2%}")
    print(f"分析完成，报告已生成")
```

---

**最后更新时间**: 2025年8月9日
**文档版本**: v2.1

> 重要更新：默认资金分配策略改为“按剩余空位等权”。计算买入股数时，先用“可用现金 ÷ 剩余空位数（max_positions - 当前持仓数）”得到目标金额，再经由风险控制（单票≤10%、现金保留≥5%）与A股成交约束（100股一手、最低成交额、费用覆盖）修正为最终股数。