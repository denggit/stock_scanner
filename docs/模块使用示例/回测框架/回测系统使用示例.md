# 回测系统使用示例

**文档版本**: v2.0  
**最后更新时间**: 2025年8月5日

## 📋 概述

本回测系统基于 `backtrader` 构建，采用设计模式设计，提供灵活、高效的回测功能。支持单策略回测、多策略对比、参数优化等多种场景。

**核心特点：**

- ✅ **设计模式驱动**：使用策略模式、工厂模式等设计模式
- ✅ **灵活扩展**：易于添加新的交易策略
- ✅ **多种回测模式**：单策略、多策略、参数优化
- ✅ **完整分析**：提供详细的性能指标和风险分析
- ✅ **可视化支持**：支持图表绘制和结果展示

## 🚀 快速开始

### 1. 基础单策略回测

```python
import pandas as pd
from backend.business.backtest_event import run_backtest, MAStrategy
from backend.business.data.data_fetcher import StockDataFetcher

# 获取股票数据
fetcher = StockDataFetcher()
df = fetcher.fetch_stock_data('sh.600900', start_date='2024-01-01', end_date='2024-12-31')

# 运行简单回测
results = run_backtest(
    data=df,
    strategy_class=MAStrategy,
    initial_cash=100000,
    commission=0.0003,
    strategy_params={'short_period': 10, 'long_period': 30},
    strategy_name="MA策略",
    plot=True
)

print(f"总收益率: {results['summary']['total_return']:.2%}")
print(f"夏普比率: {results['summary']['sharpe_ratio']:.2f}")
print(f"最大回撤: {results['summary']['max_drawdown']:.2%}")
```

### 2. 使用便捷函数

```python
from backend.business.backtest_event import run_backtest, MAStrategy, RSIStrategy

# 获取数据
df = fetcher.fetch_stock_data('sh.600900', start_date='2024-01-01', end_date='2024-12-31')

# 运行MA策略回测
ma_results = run_backtest(
    data=df,
    strategy_class=MAStrategy,
    strategy_params={'short_period': 5, 'long_period': 20},
    strategy_name="短期MA策略"
)

# 运行RSI策略回测
rsi_results = run_backtest(
    data=df,
    strategy_class=RSIStrategy,
    strategy_params={'rsi_period': 14, 'oversold': 30, 'overbought': 70},
    strategy_name="RSI策略"
)

# 对比结果
print("MA策略收益率:", f"{ma_results['summary']['total_return']:.2%}")
print("RSI策略收益率:", f"{rsi_results['summary']['total_return']:.2%}")
```

## 🔧 高级功能

### 1. 多策略回测

```python
from backend.business.backtest_event import run_multi_strategy_backtest

# 定义多个策略
strategies = [
    {
        'name': 'MA策略',
        'class': MAStrategy,
        'params': {'short_period': 10, 'long_period': 30}
    },
    {
        'name': 'RSI策略',
        'class': RSIStrategy,
        'params': {'rsi_period': 14, 'oversold': 30, 'overbought': 70}
    },
    {
        'name': 'MACD策略',
        'class': MACDStrategy,
        'params': {'fast_period': 12, 'slow_period': 26, 'signal_period': 9}
    }
]

# 运行多策略回测
multi_results = run_multi_strategy_backtest(
    data=df,
    strategies=strategies,
    initial_cash=100000,
    commission=0.0003
)

# 查看各策略表现
for strategy_name, result in multi_results['strategies'].items():
    print(f"{strategy_name}: {result['summary']['total_return']:.2%}")
```

### 2. 参数优化

```python
from backend.business.backtest_event import optimize_parameters

# 定义参数范围
parameter_ranges = {
    'short_period': [5, 10, 15, 20],
    'long_period': [20, 30, 40, 50]
}

# 运行参数优化
optimization_results = optimize_parameters(
    data=df,
    strategy_class=MAStrategy,
    parameter_ranges=parameter_ranges,
    initial_cash=100000,
    commission=0.0003,
    optimization_target="总收益率"
)

# 查看最优参数
best_params = optimization_results['best_parameters']
best_return = optimization_results['best_return']
print(f"最优参数: {best_params}")
print(f"最优收益率: {best_return:.2%}")
```

### 3. 自定义策略开发

```python
from backend.business.backtest_event.core.base_strategy import BaseStrategy
import backtrader as bt

class MyCustomStrategy(BaseStrategy):
    """自定义策略示例"""
    
    def __init__(self, ma_period=20, rsi_period=14):
        super().__init__()
        
        # 技术指标
        self.ma = bt.indicators.SMA(self.dataclose, period=ma_period)
        self.rsi = bt.indicators.RSI(self.dataclose, period=rsi_period)
        
        # 策略参数
        self.ma_period = ma_period
        self.rsi_period = rsi_period
    
    def next(self):
        """策略逻辑"""
        if self.order:
            return
            
        if not self.position:
            # 买入条件：价格在均线上方且RSI < 70
            if (self.dataclose[0] > self.ma[0] and 
                self.rsi[0] < 70):
                self.execute_buy()
        else:
            # 卖出条件：价格跌破均线或RSI > 80
            if (self.dataclose[0] < self.ma[0] or 
                self.rsi[0] > 80):
                self.execute_sell()
    
    def _get_parameters(self):
        """获取策略参数"""
        return {
            'ma_period': self.ma_period,
            'rsi_period': self.rsi_period
        }

# 使用自定义策略
custom_results = run_backtest(
    data=df,
    strategy_class=MyCustomStrategy,
    strategy_params={'ma_period': 20, 'rsi_period': 14},
    strategy_name="自定义策略"
)
```

## 📊 结果分析

### 1. 基础性能指标

```python
def analyze_results(results):
    """分析回测结果"""
    summary = results['summary']
    
    print("=== 回测结果分析 ===")
    print(f"总收益率: {summary['total_return']:.2%}")
    print(f"年化收益率: {summary['annual_return']:.2%}")
    print(f"夏普比率: {summary['sharpe_ratio']:.2f}")
    print(f"最大回撤: {summary['max_drawdown']:.2%}")
    print(f"胜率: {summary['win_rate']:.2%}")
    print(f"总交易次数: {summary['total_trades']}")
    print(f"盈亏比: {summary['profit_factor']:.2f}")

# 使用示例
analyze_results(results)
```

### 2. 详细交易记录

```python
def analyze_trades(results):
    """分析交易记录"""
    trades = results['trades']
    
    print("=== 交易记录分析 ===")
    print(f"总交易次数: {len(trades)}")
    
    # 统计盈利和亏损交易
    profitable_trades = [t for t in trades if t['pnl'] > 0]
    losing_trades = [t for t in trades if t['pnl'] < 0]
    
    print(f"盈利交易: {len(profitable_trades)}")
    print(f"亏损交易: {len(losing_trades)}")
    
    if profitable_trades:
        avg_profit = sum(t['pnl'] for t in profitable_trades) / len(profitable_trades)
        print(f"平均盈利: {avg_profit:.2f}")
    
    if losing_trades:
        avg_loss = sum(t['pnl'] for t in losing_trades) / len(losing_trades)
        print(f"平均亏损: {avg_loss:.2f}")

# 使用示例
analyze_trades(results)
```

### 3. 风险分析

```python
def analyze_risk(results):
    """风险分析"""
    risk_metrics = results['risk_metrics']
    
    print("=== 风险分析 ===")
    print(f"波动率: {risk_metrics['volatility']:.2%}")
    print(f"VaR(95%): {risk_metrics['var_95']:.2%}")
    print(f"CVaR(95%): {risk_metrics['cvar_95']:.2%}")
    print(f"Calmar比率: {risk_metrics['calmar_ratio']:.2f}")

# 使用示例
analyze_risk(results)
```

## 🌐 Web界面使用

### 1. 通过前端界面使用

访问 `http://localhost:8501/backtest` 使用Web界面：

```python
# 前端界面配置示例
backtest_config = {
    "strategy": "MA策略",
    "start_date": "2024-01-01",
    "end_date": "2024-12-31",
    "params": {
        "short_period": 10,
        "long_period": 30
    },
    "backtest_init_params": {
        "stock_pool": "非ST股票",
        "initial_capital": 100000,
        "max_positions": 4,
        "allocation_strategy": "信号强度加权"
    }
}
```

### 2. API接口调用

```python
import requests
import json

def run_backtest_api(strategy, start_date, end_date, params, init_params):
    """通过API运行回测"""
    url = "http://localhost:8000/api/backtest/run"
    
    request_params = {
        "strategy": strategy,
        "start_date": start_date,
        "end_date": end_date,
        "params": json.dumps(params),
        "backtest_init_params": json.dumps(init_params)
    }
    
    response = requests.get(url, params=request_params)
    return response.json()

# 使用示例
results = run_backtest_api(
    strategy="MA策略",
    start_date="2024-01-01",
    end_date="2024-12-31",
    params={"short_period": 10, "long_period": 30},
    init_params={
        "stock_pool": "非ST股票",
        "initial_capital": 100000,
        "max_positions": 4
    }
)
```

## 🔍 内置策略说明

### 1. MA策略 (移动平均策略)

```python
class MAStrategy(BaseStrategy):
    """移动平均策略"""
    
    def __init__(self, short_period=10, long_period=30):
        # 短期均线上穿长期均线买入
        # 短期均线下穿长期均线卖出
```

**参数说明：**
- `short_period`: 短期移动平均周期 (默认: 10)
- `long_period`: 长期移动平均周期 (默认: 30)

### 2. RSI策略 (相对强弱指标策略)

```python
class RSIStrategy(BaseStrategy):
    """RSI策略"""
    
    def __init__(self, rsi_period=14, oversold=30, overbought=70):
        # RSI < oversold 买入
        # RSI > overbought 卖出
```

**参数说明：**
- `rsi_period`: RSI计算周期 (默认: 14)
- `oversold`: 超卖阈值 (默认: 30)
- `overbought`: 超买阈值 (默认: 70)

### 3. MACD策略 (MACD指标策略)

```python
class MACDStrategy(BaseStrategy):
    """MACD策略"""
    
    def __init__(self, fast_period=12, slow_period=26, signal_period=9):
        # MACD金叉买入
        # MACD死叉卖出
```

**参数说明：**
- `fast_period`: 快线周期 (默认: 12)
- `slow_period`: 慢线周期 (默认: 26)
- `signal_period`: 信号线周期 (默认: 9)

### 4. DualThrust策略 (双轨策略)

```python
class DualThrustStrategy(BaseStrategy):
    """双轨策略"""
    
    def __init__(self, period=20, k1=0.7, k2=0.7):
        # 突破上轨买入
        # 突破下轨卖出
```

**参数说明：**
- `period`: 计算周期 (默认: 20)
- `k1`: 上轨系数 (默认: 0.7)
- `k2`: 下轨系数 (默认: 0.7)

## ⚠️ 注意事项

### 1. 数据要求

```python
# 数据格式要求
required_columns = ['open', 'high', 'low', 'close', 'volume']
date_column = 'datetime'  # 或 'date'

# 数据预处理
def prepare_data(df):
    """准备回测数据"""
    # 确保列名正确
    df = df.rename(columns={
        'trade_date': 'datetime',
        'amount': 'volume'
    })
    
    # 设置索引
    df['datetime'] = pd.to_datetime(df['datetime'])
    df.set_index('datetime', inplace=True)
    
    # 确保数据类型
    for col in ['open', 'high', 'low', 'close', 'volume']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    return df
```

### 2. 性能优化

```python
# 大数据量优化
def optimize_for_large_data(df, strategy_class, **kwargs):
    """大数据量优化"""
    # 1. 数据采样
    if len(df) > 10000:
        df = df.resample('D').last().dropna()
    
    # 2. 使用更高效的参数
    kwargs['plot'] = False  # 关闭绘图提高速度
    
    # 3. 分批处理
    results = run_backtest(df, strategy_class, **kwargs)
    return results
```

### 3. 常见问题解决

```python
# 问题1: 数据不足
def check_data_sufficiency(df, min_days=100):
    """检查数据是否足够"""
    if len(df) < min_days:
        raise ValueError(f"数据不足，至少需要{min_days}个交易日")

# 问题2: 参数验证
def validate_strategy_params(params):
    """验证策略参数"""
    if 'short_period' in params and 'long_period' in params:
        if params['short_period'] >= params['long_period']:
            raise ValueError("短期周期必须小于长期周期")

# 问题3: 资金管理
def check_capital_sufficiency(initial_cash, min_capital=10000):
    """检查初始资金是否足够"""
    if initial_cash < min_capital:
        raise ValueError(f"初始资金不足，至少需要{min_capital}元")
```

## 📝 完整示例

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
回测系统完整使用示例
"""

import pandas as pd
from backend.business.backtest_event import (
    run_backtest, 
    run_multi_strategy_backtest,
    optimize_parameters,
    MAStrategy, 
    RSIStrategy, 
    MACDStrategy
)
from backend.business.data.data_fetcher import StockDataFetcher

def main():
    """主函数"""
    # 1. 获取数据
    fetcher = StockDataFetcher()
    df = fetcher.fetch_stock_data(
        'sh.600900', 
        start_date='2024-01-01', 
        end_date='2024-12-31'
    )
    
    print(f"获取数据: {len(df)} 条记录")
    
    # 2. 单策略回测
    print("\n=== 单策略回测 ===")
    ma_results = run_backtest(
        data=df,
        strategy_class=MAStrategy,
        strategy_params={'short_period': 10, 'long_period': 30},
        strategy_name="MA策略"
    )
    
    print(f"MA策略收益率: {ma_results['summary']['total_return']:.2%}")
    
    # 3. 多策略对比
    print("\n=== 多策略对比 ===")
    strategies = [
        {
            'name': 'MA策略',
            'class': MAStrategy,
            'params': {'short_period': 10, 'long_period': 30}
        },
        {
            'name': 'RSI策略',
            'class': RSIStrategy,
            'params': {'rsi_period': 14, 'oversold': 30, 'overbought': 70}
        },
        {
            'name': 'MACD策略',
            'class': MACDStrategy,
            'params': {'fast_period': 12, 'slow_period': 26, 'signal_period': 9}
        }
    ]
    
    multi_results = run_multi_strategy_backtest(
        data=df,
        strategies=strategies,
        initial_cash=100000
    )
    
    for strategy_name, result in multi_results['strategies'].items():
        print(f"{strategy_name}: {result['summary']['total_return']:.2%}")
    
    # 4. 参数优化
    print("\n=== 参数优化 ===")
    parameter_ranges = {
        'short_period': [5, 10, 15],
        'long_period': [20, 30, 40]
    }
    
    opt_results = optimize_parameters(
        data=df,
        strategy_class=MAStrategy,
        parameter_ranges=parameter_ranges,
        optimization_target="总收益率"
    )
    
    print(f"最优参数: {opt_results['best_parameters']}")
    print(f"最优收益率: {opt_results['best_return']:.2%}")
    
    return ma_results, multi_results, opt_results

if __name__ == "__main__":
    ma_results, multi_results, opt_results = main()
```

## 🔗 相关文档

- [回测框架开发文档](../模块开发文档/回测框架/回测框架开发文档.md)
- [策略开发指南](../模块开发文档/回测框架/策略开发指南.md)
- [API接口文档](../../API接口文档.md)

---

**最后更新**: 2025年8月9日  
**版本**: v2.1  
**重要变更**: 默认资金分配策略已更新为“按剩余空位等权”。

> 资金分配说明：买入股数的初始计算基于“可用现金 ÷ 剩余空位数（max_positions - 当前持仓数）”，随后应用风险控制（单票占比、最低现金留存）与A股成交约束（100股一手、最低成交额、费用覆盖）进行调整。