# 回测框架日志管理规范

## 概述

回测框架采用统一的日志管理策略，所有回测相关的模块都使用名为"backtest"的日志记录器，确保日志的一致性和可追踪性。

## 日志记录器统一性

### 1. 统一日志记录器名称

所有回测模块都使用 `logging.getLogger("backtest")` 来获取日志记录器：

```python
# 正确的用法
logger = logging.getLogger("backtest_event")

# 错误的用法
logger = logging.getLogger(__name__)  # 会产生不同的日志记录器名称
```

### 2. 已统一的模块

以下模块已经统一使用"backtest"日志记录器：

#### 核心模块
- `BacktestEngine`: 回测引擎
- `DataManager`: 数据管理器
- `ResultAnalyzer`: 结果分析器

#### 策略模块
- `RisingChannelBacktestStrategy`: 上升通道策略
- 其他所有策略类

#### 工具模块
- `DataUtils`: 数据工具类
- `ReportUtils`: 报告工具类

### 3. 日志记录器配置示例

```python
class BacktestEngine:
    def __init__(self):
        # 统一使用backtest主日志记录器，便于全局日志管理和追踪
        self.logger = logging.getLogger("backtest_event")
        
class DataManager:
    def __init__(self):
        # 统一使用backtest主日志记录器，便于全局日志管理和追踪
        self.logger = logging.getLogger("backtest_event")
        
class RisingChannelBacktestStrategy(BaseStrategy):
    def __init__(self, **params):
        super().__init__(**params)
        
        # 统一使用backtest主日志记录器，便于全局日志管理和追踪
        self.logger = logging.getLogger("backtest_event")
```

## 日志级别规范

### 1. 日志级别定义

```python
# DEBUG: 详细的调试信息
logger.debug("详细的调试信息")

# INFO: 一般信息
logger.info("开始回测流程")

# WARNING: 警告信息
logger.warning("股票数据为空")

# ERROR: 错误信息
logger.error("数据获取失败")

# CRITICAL: 严重错误
logger.critical("系统严重错误")
```

### 2. 使用场景

#### DEBUG级别
- 详细的算法计算过程
- 数据处理的中间步骤
- 策略决策的详细逻辑

#### INFO级别
- 回测流程的开始和结束
- 重要操作的完成状态
- 数据加载和处理的进度

#### WARNING级别
- 数据质量问题
- 策略参数异常
- 非致命的错误情况

#### ERROR级别
- 数据获取失败
- 策略执行错误
- 系统配置问题

## 日志格式规范

### 1. 标准日志格式

```python
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
```

### 2. 日志输出示例

```
2024-01-15 10:30:15,123 - backtest - INFO - 开始回测流程
2024-01-15 10:30:15,124 - backtest - INFO - 数据管理器初始化完成
2024-01-15 10:30:15,125 - backtest - INFO - 策略初始化完成
2024-01-15 10:30:15,126 - backtest - WARNING - 股票 000001.SZ 数据为空
2024-01-15 10:30:15,127 - backtest - INFO - 回测完成
```

## 日志文件管理

### 1. 日志文件命名

```python
# 使用setup_logger函数创建日志记录器
from backend.utils.logger import setup_logger

# 创建backtest日志记录器
logger = setup_logger("backtest_event", log_dir="logs")
```

### 2. 日志文件结构

```
logs/
└── backtest/
    ├── backtest_2024-01-15.log
    ├── backtest_2024-01-16.log
    └── backtest_2024-01-17.log
```

### 3. 日志轮转

- 按日期自动轮转
- 保留历史日志文件
- 支持日志压缩和清理

## 最佳实践

### 1. 日志记录原则

#### 记录关键信息
```python
# 好的做法
logger.info(f"开始处理股票池: {stock_pool}, 股票数量: {len(stock_list)}")

# 避免过度记录
logger.debug(f"处理第 {i} 只股票: {stock_code}")  # 只在DEBUG级别记录
```

#### 使用结构化信息
```python
# 好的做法
logger.info("策略执行完成", extra={
    'strategy_name': 'RisingChannel',
    'trade_count': 10,
    'total_return': 0.15
})
```

### 2. 错误处理

```python
try:
    # 执行操作
    result = perform_operation()
    logger.info("操作执行成功")
except Exception as e:
    logger.error(f"操作执行失败: {e}", exc_info=True)
    # 继续处理或抛出异常
```

### 3. 性能考虑

```python
# 避免在循环中频繁记录
for i, stock in enumerate(stocks):
    if i % 100 == 0:  # 每100只股票记录一次进度
        logger.info(f"处理进度: {i}/{len(stocks)}")
    
    # 处理股票数据
    process_stock(stock)
```

## 日志监控和分析

### 1. 日志分析工具

可以使用以下工具分析日志：

- **grep**: 搜索特定信息
- **awk**: 提取和统计日志数据
- **Python脚本**: 自定义日志分析

### 2. 常见分析场景

#### 错误统计
```bash
grep "ERROR" logs/backtest_event/backtest_2024-01-15.log | wc -l
```

#### 性能分析
```bash
grep "执行时间" logs/backtest_event/backtest_2024-01-15.log
```

#### 策略执行统计
```bash
grep "策略执行" logs/backtest_event/backtest_2024-01-15.log
```

## 配置示例

### 1. 开发环境配置

```python
import logging

# 设置日志级别
logging.getLogger("backtest_event").setLevel(logging.DEBUG)

# 添加控制台处理器
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)
logging.getLogger("backtest_event").addHandler(console_handler)
```

### 2. 生产环境配置

```python
from backend.utils.logger import setup_logger

# 创建生产环境日志记录器
logger = setup_logger("backtest_event", log_level=logging.INFO)
```

## 注意事项

### 1. 避免的问题

- ❌ 使用 `__name__` 作为日志记录器名称
- ❌ 在循环中频繁记录日志
- ❌ 记录敏感信息（如密码、API密钥）
- ❌ 日志级别设置不当

### 2. 推荐做法

- ✅ 统一使用"backtest"日志记录器
- ✅ 合理设置日志级别
- ✅ 记录有意义的上下文信息
- ✅ 使用异常处理记录错误

## 日志重复问题修复

### 问题描述

在回测过程中，发现日志出现重复输出的问题，每条日志都会输出两次：
```
2025-08-16 17:13:45,867 - base_strategy.py:102 - INFO - ========回测交易日: 2024-03-11========
INFO:backtest:========回测交易日: 2024-03-11========
```

### 问题原因

1. **多个模块重复初始化**：多个模块都在初始化时调用 `setup_logger("backtest")`，导致处理器被重复添加
2. **处理器检查不完善**：原有的 `hasHandlers()` 检查不够严格，无法正确识别重复的处理器
3. **backtrader 框架干扰**：backtrader 框架在 `cerebro.run()` 时会自动配置日志，产生不同格式的重复日志

### 解决方案

#### 1. 实现单例模式

在 `backend/utils/logger.py` 中实现了 `LoggerManager` 类，使用单例模式确保每个名称的日志记录器只被初始化一次：

```python
class LoggerManager:
    """日志记录器管理器，使用单例模式确保每个名称的日志记录器只被初始化一次"""
    
    _instances = {}
    
    @classmethod
    def get_logger(cls, name: str, log_dir: str = "logs", log_level=logging.INFO, set_root_logger=False) -> logging.Logger:
        # 如果已经存在该名称的日志记录器，直接返回
        if name in cls._instances:
            return cls._instances[name]
        
        # 创建新的日志记录器
        logger = cls._create_logger(name, log_dir, log_level, set_root_logger)
        cls._instances[name] = logger
        return logger
```

#### 2. 禁用 backtrader 默认日志

在 `BacktestEngine` 和 `BaseStrategy` 中禁用 backtrader 的默认日志配置：

```python
def _disable_backtrader_logging(self):
    """禁用backtrader的默认日志配置"""
    try:
        # 禁用backtrader的默认日志处理器
        for logger_name in ['backtrader', 'bt', 'cerebro']:
            logger = logging.getLogger(logger_name)
            logger.disabled = True
            # 清除可能存在的处理器
            for handler in logger.handlers[:]:
                logger.removeHandler(handler)
    except Exception as e:
        self.logger.warning(f"禁用backtrader日志配置时出现警告: {e}")
```

#### 3. 保持向后兼容

修改 `setup_logger` 函数，使其调用 `LoggerManager.get_logger`，保持向后兼容：

```python
def setup_logger(name: str, log_dir: str = "logs", log_level=logging.INFO, set_root_logger=False) -> logging.Logger:
    """
    设置日志记录器（兼容旧接口）
    """
    return LoggerManager.get_logger(name, log_dir, log_level, set_root_logger)
```

### 修复效果

1. **消除重复日志**：每条日志只输出一次，不再出现重复
2. **统一日志格式**：所有日志都使用统一的格式输出
3. **保持功能完整**：所有日志功能正常工作
4. **向后兼容**：现有代码无需修改
5. **性能优化**：避免重复创建处理器

### 验证方法

可以通过以下方式验证修复效果：

```python
# 测试代码
from backend.business.backtest_event.execution.rising_channel_backtest import RisingChannelBacktestRunner
import logging

# 创建回测运行器
runner = RisingChannelBacktestRunner(
    log_level=logging.INFO,
    environment='development'
)

# 检查日志记录器状态
print(f"处理器数量: {len(runner.logger.handlers)}")  # 应该输出 2

# 检查backtrader日志记录器是否被禁用
bt_logger = logging.getLogger('backtrader')
print(f"backtrader日志记录器是否禁用: {bt_logger.disabled}")  # 应该输出 True
print(f"backtrader处理器数量: {len(bt_logger.handlers)}")  # 应该输出 0

# 测试日志输出
runner.logger.info("测试日志")
# 应该只输出一次，而不是两次
```

### 注意事项

1. **单例作用域**：单例模式在同一个Python进程内有效
2. **不同名称独立**：不同名称的日志记录器仍然是独立的实例
3. **线程安全**：当前实现不是线程安全的，如需多线程支持需要添加锁机制
4. **backtrader 兼容性**：禁用 backtrader 日志不会影响其功能，只是避免了重复输出 