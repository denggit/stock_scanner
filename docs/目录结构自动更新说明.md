# 📁 目录结构自动更新说明

## 📋 概述

本文档说明如何自动更新项目的目录结构文档，确保文档与实际代码结构保持同步。

## 🔧 更新工具

### 1. 自动更新脚本

项目提供了自动更新目录结构的脚本：

```bash
# 运行自动更新脚本
python scripts/update_directory_structure.py
```

### 2. 手动更新

如果自动脚本不可用，可以手动更新：

```bash
# 生成目录树
tree -I 'venv|__pycache__|*.pyc|.git|.DS_Store' > temp_structure.txt

# 或者使用find命令
find . -type f -name "*.py" -o -name "*.md" -o -name "*.yaml" -o -name "*.json" | grep -v venv | grep -v __pycache__ > temp_structure.txt
```

## 📊 目录结构规范

### 1. 文件命名规范

- **Python文件**: 使用小写字母和下划线，如 `data_fetcher.py`
- **配置文件**: 使用小写字母和下划线，如 `channel_config.yaml`
- **文档文件**: 使用中文描述，如 `上升通道回归模块使用示例.md`
- **目录名**: 使用小写字母和下划线，如 `channel_analysis`

### 2. 目录组织规范

```
backend/
├── business/           # 业务层（统一管理所有业务逻辑）
│   ├── backtest/      # 回测业务
│   ├── data/          # 数据业务
│   ├── factor/        # 因子业务
│   ├── ml/            # 机器学习业务
│   └── strategies/    # 策略业务
├── services/          # 服务层
├── interface/         # 接口层
└── utils/             # 工具层
```

### 3. 文档组织规范

```
docs/
├── 模块使用示例/      # 使用示例文档
│   ├── 上升通道/     # 上升通道相关示例
│   └── 回测框架/     # 回测框架相关示例
├── 模块开发文档/      # 开发文档
│   ├── 上升通道/     # 上升通道开发文档
│   └── 回测框架/     # 回测框架开发文档
└── 项目文档/         # 项目级文档
```

## 🔄 更新流程

### 1. 检测变更

```python
import os
import hashlib
import json

def detect_changes():
    """检测目录结构变更"""
    
    # 计算当前目录结构的哈希值
    current_hash = calculate_directory_hash()
    
    # 读取上次的哈希值
    try:
        with open('.directory_hash', 'r') as f:
            last_hash = f.read().strip()
    except FileNotFoundError:
        last_hash = None
    
    # 比较哈希值
    if current_hash != last_hash:
        print("检测到目录结构变更，需要更新文档")
        return True
    else:
        print("目录结构无变更")
        return False

def calculate_directory_hash():
    """计算目录结构的哈希值"""
    structure = []
    
    for root, dirs, files in os.walk('.'):
        # 忽略特定目录
        dirs[:] = [d for d in dirs if d not in ['venv', '__pycache__', '.git', '.DS_Store']]
        
        for file in files:
            if file.endswith(('.py', '.md', '.yaml', '.json')):
                rel_path = os.path.relpath(os.path.join(root, file), '.')
                structure.append(rel_path)
    
    # 排序确保一致性
    structure.sort()
    
    # 计算哈希值
    content = '\n'.join(structure).encode('utf-8')
    return hashlib.md5(content).hexdigest()
```

### 2. 生成目录树

```python
def generate_directory_tree():
    """生成目录树结构"""
    
    tree_lines = []
    
    def add_to_tree(path, prefix="", is_last=True):
        """递归添加目录到树结构"""
        
        # 获取目录内容
        try:
            items = os.listdir(path)
        except PermissionError:
            return
        
        # 过滤和排序
        items = [item for item in items if not item.startswith('.') and item not in ['venv', '__pycache__']]
        items.sort()
        
        # 分离文件和目录
        dirs = [item for item in items if os.path.isdir(os.path.join(path, item))]
        files = [item for item in items if os.path.isfile(os.path.join(path, item))]
        
        # 添加目录
        for i, dir_name in enumerate(dirs):
            is_last_dir = i == len(dirs) - 1 and len(files) == 0
            tree_lines.append(f"{prefix}{'└── ' if is_last_dir else '├── '}📁 {dir_name}")
            
            new_prefix = prefix + ('    ' if is_last_dir else '│   ')
            add_to_tree(os.path.join(path, dir_name), new_prefix, is_last_dir)
        
        # 添加文件
        for i, file_name in enumerate(files):
            is_last_file = i == len(files) - 1
            tree_lines.append(f"{prefix}{'└── ' if is_last_file else '├── '}📄 {file_name}")
    
    # 从根目录开始
    add_to_tree('.')
    
    return tree_lines
```

### 3. 更新文档

```python
def update_documentation():
    """更新文档"""
    
    # 生成新的目录树
    tree_lines = generate_directory_tree()
    
    # 读取现有文档
    with open('docs/项目目录结构.md', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 找到目录树部分并替换
    start_marker = "```\n└── 📁 stock_scanner"
    end_marker = "```\n\n## 📋 目录结构说明"
    
    start_pos = content.find(start_marker)
    end_pos = content.find(end_marker)
    
    if start_pos != -1 and end_pos != -1:
        # 构建新的目录树内容
        new_tree_content = "```\n└── 📁 stock_scanner\n"
        for line in tree_lines[1:]:  # 跳过根目录行
            new_tree_content += f"    {line}\n"
        new_tree_content += "```\n\n## 📋 目录结构说明"
        
        # 替换内容
        new_content = content[:start_pos] + new_tree_content + content[end_pos + len(end_marker):]
        
        # 写入文件
        with open('docs/项目目录结构.md', 'w', encoding='utf-8') as f:
            f.write(new_content)
        
        print("文档更新完成")
    else:
        print("未找到目录树标记，请手动更新")
```

### 4. 保存哈希值

```python
def save_directory_hash():
    """保存目录结构哈希值"""
    
    current_hash = calculate_directory_hash()
    
    with open('.directory_hash', 'w') as f:
        f.write(current_hash)
    
    print(f"目录结构哈希值已保存: {current_hash}")
```

## 🚀 自动化脚本

### 完整的更新脚本

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Author     : AI Assistant
@Date       : 2025-01-29
@File       : update_directory_structure.py
@Description: 自动更新项目目录结构文档
"""

import os
import hashlib
import json
from datetime import datetime

def main():
    """主函数"""
    
    print("🔄 开始检查目录结构变更...")
    
    # 检测变更
    if detect_changes():
        print("📝 检测到变更，开始更新文档...")
        
        # 更新文档
        update_documentation()
        
        # 保存哈希值
        save_directory_hash()
        
        print("✅ 目录结构文档更新完成")
    else:
        print("✅ 目录结构无变更，无需更新")

if __name__ == "__main__":
    main()
```

## 📋 手动更新检查清单

如果自动更新不可用，请按以下清单手动更新：

### 1. 检查新增文件/目录

- [ ] 检查 `backend/` 目录下是否有新增的业务模块
- [ ] 检查 `pages/` 目录下是否有新增的前端页面
- [ ] 检查 `docs/` 目录下是否有新增的文档
- [ ] 检查 `scripts/` 目录下是否有新增的脚本

### 2. 检查删除的文件/目录

- [ ] 确认已删除的文件/目录已从文档中移除
- [ ] 更新相关的引用和链接

### 3. 检查重命名的文件/目录

- [ ] 更新文档中的文件/目录名称
- [ ] 更新相关的引用和链接

### 4. 更新文档内容

- [ ] 更新 `docs/项目目录结构.md` 中的目录树
- [ ] 更新 `docs/快速参考手册.md` 中的路径引用
- [ ] 更新 `docs/API接口文档.md` 中的模块路径
- [ ] 更新 `docs/项目工具功能文档.md` 中的文件路径

## 🔍 验证更新

### 1. 检查文档一致性

```python
def verify_documentation_consistency():
    """验证文档一致性"""
    
    # 读取目录结构文档
    with open('docs/项目目录结构.md', 'r', encoding='utf-8') as f:
        structure_content = f.read()
    
    # 检查关键路径是否存在
    key_paths = [
        'backend/business/',
        'backend/services/',
        'backend/interface/',
        'backend/utils/',
        'pages/',
        'docs/',
        'scripts/'
    ]
    
    missing_paths = []
    for path in key_paths:
        if path not in structure_content:
            missing_paths.append(path)
    
    if missing_paths:
        print(f"⚠️ 文档中缺少以下路径: {missing_paths}")
        return False
    else:
        print("✅ 文档一致性检查通过")
        return True
```

### 2. 检查链接有效性

```python
def check_document_links():
    """检查文档中的链接有效性"""
    
    # 读取所有文档
    doc_files = []
    for root, dirs, files in os.walk('docs'):
        for file in files:
            if file.endswith('.md'):
                doc_files.append(os.path.join(root, file))
    
    broken_links = []
    
    for doc_file in doc_files:
        with open(doc_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # 检查文件引用
        import re
        file_refs = re.findall(r'`([^`]+\.py)`', content)
        
        for ref in file_refs:
            if not os.path.exists(ref):
                broken_links.append((doc_file, ref))
    
    if broken_links:
        print("⚠️ 发现无效链接:")
        for doc_file, link in broken_links:
            print(f"  {doc_file}: {link}")
        return False
    else:
        print("✅ 所有链接有效")
        return True
```

## 📝 更新日志

### 版本历史

- **v2.0** (2025-01-29): 重构为业务层架构，更新所有文档
- **v1.5** (2024-12-31): 添加上升通道模块文档
- **v1.0** (2024-11-15): 初始版本

### 最近更新

- ✅ 更新项目目录结构，反映业务层重构
- ✅ 更新快速参考手册，添加新的API和功能
- ✅ 更新API接口文档，改进错误处理
- ✅ 更新项目工具功能文档，完善使用示例
- ✅ 更新模块使用示例，添加高级功能
- ✅ 更新回测框架文档，添加自定义策略示例

## 🆘 故障排除

### 常见问题

1. **自动更新脚本失败**
   - 检查Python环境
   - 确认文件权限
   - 查看错误日志

2. **文档格式错误**
   - 检查Markdown语法
   - 确认编码格式
   - 验证特殊字符

3. **目录结构不一致**
   - 手动检查文件路径
   - 更新哈希值
   - 重新运行更新脚本

### 联系支持

如果遇到问题，请：
1. 查看错误日志
2. 检查文件权限
3. 确认Python版本
4. 联系项目维护者

---

**最后更新时间**: 2025年8月5日
**文档版本**: v2.0 